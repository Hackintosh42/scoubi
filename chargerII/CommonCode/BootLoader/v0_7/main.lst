   1               		.file	"main.c"
   2               		.arch atmega168
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  69               	.global	jump_to_app
  70               	.global	jump_to_app
  71               		.section .bss
  74               	jump_to_app:
  75 0000 0000      		.skip 2,0
  76               		.text
  78               	.global	send_boot
  80               	send_boot:
   1:main.c        **** /*****************************************************************************
   2:main.c        **** *
   3:main.c        **** * AVRPROG compatible boot-loader
   4:main.c        **** * Version  : 0.7 (Feb. 2005)
   5:main.c        **** * Compiler : avr-gcc 3.4.1 / avr-libc 1.0.2 
   6:main.c        **** * size     : depends on features and startup ( minmal features < 512 words)
   7:main.c        **** * by       : Martin Thomas, Kaiserslautern, Germany
   8:main.c        **** *            eversmith@heizung-thomas.de
   9:main.c        **** *
  10:main.c        **** * License  : Copyright (c) 2005 Martin Thomas
  11:main.c        **** *            Free to use. You have to mention the copyright 
  12:main.c        **** *            owners in source-code and documentation of derived 
  13:main.c        **** *            work. No warranty.
  14:main.c        **** *
  15:main.c        **** * Tested with ATmega8, ATmega16, ATmega32, ATmega128
  16:main.c        **** *
  17:main.c        **** * - based on the Butterfly Bootloader-Code
  18:main.c        **** *   Copyright (C) 1996-1998 Atmel Corporation
  19:main.c        **** *   Author(s)     : BBrandal, PKastnes, ARodland, LHM
  20:main.c        **** *   The orignal code has been made available by ATMEL together with the 
  21:main.c        **** *   Butterfly application code. Since ATMEL.NO had no problem with 
  22:main.c        **** *   the application gcc-port they hopefully will not have any concerns about
  23:main.c        **** *   publishing this port. A lot of things have been change but the ATMEL
  24:main.c        **** *   "skeleton" is still in this code. Make sure to keep the copyright notice 
  25:main.c        **** *   in derived work to avoid trouble.
  26:main.c        **** *
  27:main.c        **** * - based on boot.h from the avr-libc (c) Eric Weddington
  28:main.c        **** *
  29:main.c        **** ****************************************************************************
  30:main.c        **** *
  31:main.c        **** *  The boot interrupt vector is included (this bootloader is completly in
  32:main.c        **** *  ".text" section). If you need this space for further functions you have to
  33:main.c        **** *  add a separate section for the bootloader-functions and add an attribute
  34:main.c        **** *  for this section to _all_ function prototypes of functions in the loader. 
  35:main.c        **** *  With this the interrupt vector will be placed at .0000 and the bootloader 
  36:main.c        **** *  code (without interrupt vector) at the adress you define in the linker
  37:main.c        **** *  options for the newly created section. See the avr-libc FAQ, the avr-
  38:main.c        **** *  libc's avr/boot.h documentation and the makefile for further details.
  39:main.c        **** *
  40:main.c        **** *  See the makefile for information how to adopt the linker-settings to 
  41:main.c        **** *  the selected Boot Size (_Bxxx below)
  42:main.c        **** *
  43:main.c        **** *  With BOOT_SIMPLE this bootloader has 0x3DE bytes size and should fit
  44:main.c        **** *  into a 512word bootloader-section.
  45:main.c        **** *
  46:main.c        **** *  Set AVR clock-frequency and the baudrate below, set MCU-type in 
  47:main.c        **** *  makefile.
  48:main.c        **** *
  49:main.c        **** ****************************************************************************/
  50:main.c        **** /*
  51:main.c        **** 	Does not work reliably so far:
  52:main.c        **** 	- lock bits set
  53:main.c        **** */
  54:main.c        **** 
  55:main.c        **** // programmers-notepad tabsize 4
  56:main.c        **** #define VERSION_HIGH '0'
  57:main.c        **** #define VERSION_LOW  '7'
  58:main.c        **** 
  59:main.c        **** #include <inttypes.h>
  60:main.c        **** #include <avr/io.h>
  61:main.c        **** #include <avr/interrupt.h>
  62:main.c        **** #include <avr/wdt.h>
  63:main.c        **** #include <avr/boot.h>
  64:main.c        **** #include <avr/pgmspace.h>
  65:main.c        **** // function not found in boot.h to read lock/fuses
  66:main.c        **** #include "lowlevel.h"
  67:main.c        **** 
  68:main.c        **** /* Pin "BLPNUM" on port "BLPORT" in this port has to grounded 
  69:main.c        ****    (active low) to start the bootloader */
  70:main.c        **** #define BLPORT  PORTC
  71:main.c        **** #define BLDDR   DDRC
  72:main.c        **** #define BLPIN   PINC
  73:main.c        **** #define BLPNUM  PINC0
  74:main.c        **** 
  75:main.c        **** /* 
  76:main.c        ****    Select startup-mode
  77:main.c        ****    * SIMPLE-Mode - Jump to bootloader main BL-loop if key is 
  78:main.c        ****      pressed (Pin grounded) "during" reset or jump to the 
  79:main.c        **** 	 application if the pin is not grounded (=pulled up by
  80:main.c        **** 	 internal pull-up-resistor)
  81:main.c        ****    * POWERSAVE-Mode - Startup is separated in two loops
  82:main.c        ****      which makes power-saving a little easier if no firmware
  83:main.c        **** 	 is on the chip. Needs more memory
  84:main.c        ****    * BOOTICE-Mode - to flash the JTAGICE upgrade.ebn file.
  85:main.c        ****      No startup-sequence in this mode. Jump directly to the
  86:main.c        ****      parser-loop on reset 
  87:main.c        ****      XTAL in BOOTICEMODE must be 7372800 Hz to be compatible
  88:main.c        ****      with the org. JTAGICE-Firmware */
  89:main.c        **** #define START_SIMPLE
  90:main.c        **** //#define START_POWERSAVE
  91:main.c        **** //#define START_BOOTICE
  92:main.c        **** 
  93:main.c        **** #ifndef START_BOOTICE
  94:main.c        **** //#define XTAL 3686400
  95:main.c        ****  #define XTAL 8000000UL
  96:main.c        **** #else
  97:main.c        **** #warning "BOOTICE mode - External Crystal/Oszillator must be 7,3728 MHz"
  98:main.c        **** #define XTAL 7372800
  99:main.c        **** #endif
 100:main.c        **** 
 101:main.c        **** // UART handling - some definitions from P. Fleury's Library - thanks
 102:main.c        **** #define BAUDRATE 19200
 103:main.c        **** #include "uart.h"
 104:main.c        **** 
 105:main.c        **** /* enable/disable readout of fuse and lock-bits 
 106:main.c        ****   (will not work for Mega169 since not supported by AVRPROG 1.37 */
 107:main.c        **** #define ENABLEREADFUSELOCK 
 108:main.c        **** 
 109:main.c        **** /* enable/disable write of lock-bits 
 110:main.c        ****   WARNING: lock-bits can not be reseted by bootloader (as far as I know)
 111:main.c        ****   Only protection no unprotection, "chip erase" from bootloader only
 112:main.c        ****   clears the flash but does no real "chip erase" (this is not possible
 113:main.c        ****   with a bootloader as far as I know)
 114:main.c        ****   Keep this undefined!
 115:main.c        ****  */
 116:main.c        **** // #define WRITELOCKBITS
 117:main.c        **** 
 118:main.c        **** /* Select Boot Size (select one, comment out the others) */
 119:main.c        **** // NO! #define _B128
 120:main.c        **** // NO! #define _B256  
 121:main.c        **** // MAYBE: #define _B512 
 122:main.c        **** #define _B1024 
 123:main.c        **** //#define _B2048
 124:main.c        **** 
 125:main.c        **** #include "chipdef.h"
 126:main.c        **** 
 127:main.c        **** #define UART_RX_BUFFER_SIZE SPM_PAGESIZE
 128:main.c        **** unsigned char gBuffer[UART_RX_BUFFER_SIZE];
 129:main.c        **** 
 130:main.c        **** #define eeprom_is_ready()             bit_is_clear(EECR, EEWE)
 131:main.c        **** #define my_eeprom_busy_wait()         do{}while(!eeprom_is_ready())
 132:main.c        **** 
 133:main.c        **** unsigned char BufferLoad(unsigned int , unsigned char ) ;
 134:main.c        **** void BlockRead(unsigned int , unsigned char ) ;
 135:main.c        **** 
 136:main.c        **** uint32_t address;
 137:main.c        **** unsigned char device;
 138:main.c        **** 
 139:main.c        **** void send_boot(void)
 140:main.c        **** {
  82               	.LM1:
  83               	/* prologue: frame size=0 */
  84               	/* prologue end (size=0) */
 141:main.c        **** 	sendchar('A');
  86               	.LM2:
  87 0000 81E4      		ldi r24,lo8(65)
  88 0002 0E94 0000 		call sendchar
 142:main.c        **** 	sendchar('V');
  90               	.LM3:
  91 0006 86E5      		ldi r24,lo8(86)
  92 0008 0E94 0000 		call sendchar
 143:main.c        **** 	sendchar('R');
  94               	.LM4:
  95 000c 82E5      		ldi r24,lo8(82)
  96 000e 0E94 0000 		call sendchar
 144:main.c        **** 	sendchar('B');
  98               	.LM5:
  99 0012 82E4      		ldi r24,lo8(66)
 100 0014 0E94 0000 		call sendchar
 145:main.c        **** 	sendchar('O');
 102               	.LM6:
 103 0018 8FE4      		ldi r24,lo8(79)
 104 001a 0E94 0000 		call sendchar
 146:main.c        **** 	sendchar('O');
 106               	.LM7:
 107 001e 8FE4      		ldi r24,lo8(79)
 108 0020 0E94 0000 		call sendchar
 147:main.c        **** 	sendchar('T');
 110               	.LM8:
 111 0024 84E5      		ldi r24,lo8(84)
 112 0026 0E94 0000 		call sendchar
 113               	/* epilogue: frame size=0 */
 114 002a 0895      		ret
 115               	/* epilogue end (size=1) */
 116               	/* function send_boot size 22 (21) */
 118               	.Lscope0:
 122               	.global	BufferLoad
 124               	BufferLoad:
 148:main.c        **** }
 149:main.c        **** 
 150:main.c        **** void (*jump_to_app)(void) = 0x0000;
 151:main.c        **** 
 152:main.c        **** int main(void)
 153:main.c        **** {
 154:main.c        **** 	unsigned  tempi;
 155:main.c        **** 	char val;
 156:main.c        ****     
 157:main.c        **** 	#ifdef START_POWERSAVE
 158:main.c        **** 	char OK = 1;    
 159:main.c        **** 	#endif
 160:main.c        ****     
 161:main.c        **** 	cli();
 162:main.c        **** 	
 163:main.c        **** 	MCUCR = (1<<IVCE);       
 164:main.c        **** 	MCUCR = (1<<IVSEL);             //move interruptvectors to the Boot sector    
 165:main.c        **** 
 166:main.c        **** 	USART_Init(UART_BAUD_SELECT(BAUDRATE,XTAL),UARTSINGLE); 	// single speed
 167:main.c        **** 	// USART_Init(UART_BAUD_SELECT(BAUDRATE/2,XTAL),UARTDOUBLE);  // double speed
 168:main.c        **** 	
 169:main.c        **** 	#if defined(START_POWERSAVE)
 170:main.c        **** 	/* 
 171:main.c        **** 		This is an adoption of the Butterfly Bootloader startup-sequence.
 172:main.c        **** 		It may look a little strange but separating the login-loop from
 173:main.c        **** 		the main parser-loop gives a lot a possibilities (timeout, sleep-modes
 174:main.c        **** 	    etc.).
 175:main.c        **** 	*/		
 176:main.c        **** 	BLDDR  &= ~(1<<BLPNUM);	// set as Input
 177:main.c        **** 	BLPORT |= (1<<BLPNUM);		// Enable pullup
 178:main.c        **** 	  
 179:main.c        **** 	for(;OK;)
 180:main.c        **** 	{
 181:main.c        **** /*		if((BLPIN & (1<<BLPNUM)))	
 182:main.c        **** 		{  
 183:main.c        **** 			// jump to main app if pin is not grounded
 184:main.c        **** 			BLPORT &= ~(1<<BLPNUM);  // set to default
 185:main.c        **** 			MCUCR = (1<<IVCE); 
 186:main.c        **** 			MCUCR = (0<<IVSEL);      // move interruptvectors to the Application sector
 187:main.c        **** 			jump_to_app();	// Jump to application sector
 188:main.c        **** 		}
 189:main.c        **** 		else
 190:main.c        **** */    
 191:main.c        **** 		{	
 192:main.c        **** 			val = recchar();
 193:main.c        **** 		
 194:main.c        **** 			if( val == 0x1B ) /* ESC */
 195:main.c        **** 	        {				// AVRPROG connection
 196:main.c        **** 				while (val != 'S')	// Wait for signon 
 197:main.c        **** 				{
 198:main.c        **** 					val = recchar();
 199:main.c        **** 				}
 200:main.c        **** 				send_boot();					// Report signon
 201:main.c        **** 				OK = 0;
 202:main.c        **** 			}
 203:main.c        **** 			else
 204:main.c        **** 				sendchar('?');
 205:main.c        **** 	        }
 206:main.c        **** 		// Power-Save code here
 207:main.c        **** 	}
 208:main.c        **** 	
 209:main.c        **** 	#elif defined(START_SIMPLE)
 210:main.c        **** 	BLDDR  &= ~(1<<BLPNUM);	// set as Input
 211:main.c        **** 	BLPORT |= (1<<BLPNUM);		// Enable pullup
 212:main.c        **** /*	
 213:main.c        **** 	if((BLPIN & (1<<BLPNUM)))
 214:main.c        **** 	{  
 215:main.c        **** 		// jump to main app if pin is not grounded
 216:main.c        **** 		BLPORT &= ~(1<<BLPNUM);  // set to default
 217:main.c        **** 		MCUCR = (1<<IVCE); 
 218:main.c        **** 		MCUCR = (0<<IVSEL);             //move interruptvectors to the Application sector
 219:main.c        **** 		jump_to_app();	// Jump to application sector
 220:main.c        **** 	}
 221:main.c        **** */  
 222:main.c        **** 
 223:main.c        **** 	#elif defined(START_BOOTICE)
 224:main.c        **** 	#warning "BOOTICE mode - no startup-condition"
 225:main.c        **** 
 226:main.c        **** 	#else
 227:main.c        **** 	#error "Select START_ condition for bootloader in main.c"
 228:main.c        **** 	#endif
 229:main.c        **** 
 230:main.c        ****     for(;;)                             
 231:main.c        ****     {   
 232:main.c        **** 		val=recchar();
 233:main.c        ****          
 234:main.c        ****         if(val=='a')                        //Autoincrement?
 235:main.c        ****         {
 236:main.c        ****           sendchar('Y');			//Autoincrement is quicker
 237:main.c        ****         }
 238:main.c        ****  
 239:main.c        ****         else if(val=='A')                   //write address 
 240:main.c        ****         {
 241:main.c        **** 			address=recchar();                //read address 8 MSB
 242:main.c        **** 			address=(address<<8)|recchar();
 243:main.c        **** 			
 244:main.c        **** 			address=address<<1;               // !! convert from word address to byte address
 245:main.c        **** 			sendchar('\r');
 246:main.c        ****         }
 247:main.c        ****         
 248:main.c        ****         else if(val=='b')
 249:main.c        **** 		{									// Buffer load support
 250:main.c        **** 			sendchar('Y');					// Report buffer load supported
 251:main.c        **** 			sendchar((UART_RX_BUFFER_SIZE >> 8) & 0xFF);
 252:main.c        **** 											// Report buffer size in bytes
 253:main.c        **** 			sendchar(UART_RX_BUFFER_SIZE & 0xFF);
 254:main.c        **** 		}
 255:main.c        **** 
 256:main.c        **** 		else if(val=='B')					// Start buffer load
 257:main.c        **** 		{
 258:main.c        **** 			tempi = recchar() << 8;			// Load high byte of buffersize
 259:main.c        **** 			tempi |= recchar();				// Load low byte of buffersize
 260:main.c        **** 			val = recchar();				// Load memory type ('E' or 'F')
 261:main.c        **** 			sendchar (BufferLoad(tempi,val));
 262:main.c        **** 											// Start downloading of buffer
 263:main.c        **** 		}
 264:main.c        **** 		
 265:main.c        **** 		else if(val == 'g')					// Block read
 266:main.c        **** 		{
 267:main.c        **** 			tempi = (recchar() << 8) | recchar();
 268:main.c        **** 
 269:main.c        **** 			val = recchar();				// Get memtype
 270:main.c        **** 			BlockRead(tempi,val);			// Perform the block read
 271:main.c        **** 		}		
 272:main.c        **** 
 273:main.c        ****         else if(val=='e')                   //Chip erase 
 274:main.c        ****         {
 275:main.c        **** 			if (device == devtype)
 276:main.c        **** 			{
 277:main.c        **** 				// erase only main section (bootloader protection)
 278:main.c        **** 				address = 0; 
 279:main.c        **** 				while ( APP_END > address )
 280:main.c        **** 				{
 281:main.c        **** 					boot_page_erase(address);	// Perform page erase
 282:main.c        **** 					boot_spm_busy_wait();		// Wait until the memory is erased.
 283:main.c        **** 					address += SPM_PAGESIZE;
 284:main.c        **** 				}
 285:main.c        **** 			}
 286:main.c        **** 			boot_rww_enable();
 287:main.c        **** 			sendchar('\r');        
 288:main.c        ****         }
 289:main.c        **** 
 290:main.c        ****         else if(val=='E')                   //Exit upgrade
 291:main.c        ****         {
 292:main.c        **** 			wdt_enable(WDTO_15MS); // Enable Watchdog Timer to give reset
 293:main.c        **** 			sendchar('\r');
 294:main.c        ****         }
 295:main.c        ****        
 296:main.c        **** 	   #ifdef WRITELOCKBITS
 297:main.c        **** 	   #warning "Extension 'WriteLockBits' enabled"
 298:main.c        **** 	   // TODO: does not work reliably
 299:main.c        ****         else if(val=='l')                   // write lockbits 
 300:main.c        ****         {
 301:main.c        **** 			if (device == devtype)
 302:main.c        **** 			{
 303:main.c        **** 				// write_lock_bits(recchar());
 304:main.c        **** 				boot_lock_bits_set(recchar());	// boot.h takes care of mask
 305:main.c        **** 				boot_spm_busy_wait();
 306:main.c        **** 			}
 307:main.c        **** 			sendchar('\r');
 308:main.c        **** 		}
 309:main.c        **** 		#endif
 310:main.c        ****         
 311:main.c        ****         else if(val=='P')     // Enter programming mode 
 312:main.c        ****         {
 313:main.c        **** 			sendchar('\r');
 314:main.c        ****         }
 315:main.c        ****         
 316:main.c        ****         else if(val=='L')   // Leave programming mode
 317:main.c        ****         { 
 318:main.c        **** 			sendchar('\r');
 319:main.c        ****         }
 320:main.c        ****         
 321:main.c        ****         else if (val=='p')		// return programmer type
 322:main.c        ****         {
 323:main.c        ****           sendchar('S');		// always serial programmer
 324:main.c        ****         } 
 325:main.c        **** 		
 326:main.c        **** #ifdef ENABLEREADFUSELOCK
 327:main.c        **** #warning "Extension 'ReadFuseLock' enabled"
 328:main.c        ****         else if(val=='F')                   // read "low" fuse bits
 329:main.c        ****         {
 330:main.c        **** 			sendchar( read_fuse_lock(0x0000, _BV(BLBSET)|_BV(SPMEN)) );
 331:main.c        ****         }
 332:main.c        **** 
 333:main.c        ****         else if(val=='r')                   // read lock bits
 334:main.c        ****         { 
 335:main.c        **** 			sendchar( read_fuse_lock(0x0001, _BV(BLBSET)|_BV(SPMEN)) );
 336:main.c        ****         }        
 337:main.c        **** 
 338:main.c        ****         else if(val=='N')                   // read high fuse bits
 339:main.c        ****         {
 340:main.c        **** 			sendchar( read_fuse_lock(0x0003,_BV(BLBSET)|_BV(SPMEN)) );
 341:main.c        ****         }        
 342:main.c        **** 
 343:main.c        ****         else if(val=='Q')                   // read extended fuse bits
 344:main.c        ****         {
 345:main.c        **** 			sendchar( read_fuse_lock(0x0002,_BV(BLBSET)|_BV(SPMEN)) );
 346:main.c        ****         }
 347:main.c        **** #endif	
 348:main.c        **** // end of ENABLEREADFUSELOCK section
 349:main.c        **** 
 350:main.c        ****         else if(val=='t')                   // Return device type 
 351:main.c        ****         {
 352:main.c        **** 			sendchar(devtype);
 353:main.c        **** 			sendchar(0);
 354:main.c        ****         }
 355:main.c        **** 
 356:main.c        ****         else if ((val=='x')||(val=='y'))	// clear and set LED ignored
 357:main.c        ****         {
 358:main.c        **** 			recchar();
 359:main.c        **** 			sendchar('\r');
 360:main.c        ****         }
 361:main.c        ****   
 362:main.c        **** 		else if (val=='T')					// set device
 363:main.c        **** 		{
 364:main.c        **** 			device = recchar();
 365:main.c        **** 			sendchar('\r');
 366:main.c        **** 		}
 367:main.c        **** 		
 368:main.c        ****         else if (val=='S')                  // Return software identifier 
 369:main.c        ****         {
 370:main.c        **** 			send_boot();
 371:main.c        ****         }                
 372:main.c        ****         
 373:main.c        ****         else if (val=='V')                  // Return Software Version
 374:main.c        ****         {
 375:main.c        **** 			sendchar(VERSION_HIGH);
 376:main.c        **** 			sendchar(VERSION_LOW);
 377:main.c        ****         }        
 378:main.c        **** 
 379:main.c        ****         else if (val=='s')                  // Return Signature Byte
 380:main.c        ****         {
 381:main.c        **** 			sendchar(sig_byte1);
 382:main.c        **** 			sendchar(sig_byte2);
 383:main.c        **** 			sendchar(sig_byte3);
 384:main.c        ****         }       
 385:main.c        **** 
 386:main.c        ****         else if(val != 0x1b) /* ESC */
 387:main.c        ****         {
 388:main.c        **** 			sendchar('?');
 389:main.c        ****         }
 390:main.c        ****     }	// end of "parser" for-loop
 391:main.c        **** 	
 392:main.c        **** 	return 0;
 393:main.c        **** }
 394:main.c        **** 
 395:main.c        **** 
 396:main.c        **** unsigned char BufferLoad(unsigned int size, unsigned char mem)
 397:main.c        **** {
 126               	.LM9:
 127               	/* prologue: frame size=0 */
 128 002c BF92      		push r11
 129 002e CF92      		push r12
 130 0030 DF92      		push r13
 131 0032 EF92      		push r14
 132 0034 FF92      		push r15
 133 0036 0F93      		push r16
 134 0038 1F93      		push r17
 135 003a CF93      		push r28
 136 003c DF93      		push r29
 137               	/* prologue end (size=9) */
 138 003e 8C01      		movw r16,r24
 139 0040 B62E      		mov r11,r22
 398:main.c        **** 	unsigned int data, cnt;
 399:main.c        **** 	uint32_t tempaddress;
 400:main.c        **** 		
 401:main.c        **** 	for (cnt=0; cnt<UART_RX_BUFFER_SIZE; cnt++) {
 141               	.LM10:
 142 0042 20E0      		ldi r18,lo8(0)
 143 0044 30E0      		ldi r19,hi8(0)
 144               	.L8:
 145 0046 E901      		movw r28,r18
 146 0048 C050      		subi r28,lo8(-(gBuffer))
 147 004a D040      		sbci r29,hi8(-(gBuffer))
 148 004c 7901      		movw r14,r18
 149 004e 0894      		sec
 150 0050 E11C      		adc r14,__zero_reg__
 151 0052 F11C      		adc r15,__zero_reg__
 402:main.c        **** 		if (cnt<size) gBuffer[cnt]=recchar();
 153               	.LM11:
 154 0054 2017      		cp r18,r16
 155 0056 3107      		cpc r19,r17
 156 0058 18F4      		brsh .L6
 157 005a 0E94 0000 		call recchar
 158 005e 01C0      		rjmp .L29
 159               	.L6:
 403:main.c        **** 		else gBuffer[cnt]=0xFF;
 161               	.LM12:
 162 0060 8FEF      		ldi r24,lo8(-1)
 163               	.L29:
 164 0062 8883      		st Y,r24
 166               	.LM13:
 167 0064 9701      		movw r18,r14
 168 0066 2038      		cpi r18,128
 169 0068 3105      		cpc r19,__zero_reg__
 170 006a 68F3      		brlo .L8
 404:main.c        **** 	}
 405:main.c        **** 	cnt=0;
 172               	.LM14:
 173 006c 20E0      		ldi r18,lo8(0)
 174 006e 30E0      		ldi r19,hi8(0)
 406:main.c        **** 
 407:main.c        **** 	tempaddress = address;					// Store address in page
 176               	.LM15:
 177 0070 C090 0000 		lds r12,address
 178 0074 D090 0000 		lds r13,(address)+1
 179 0078 E090 0000 		lds r14,(address)+2
 180 007c F090 0000 		lds r15,(address)+3
 181               	.L9:
 408:main.c        **** 	
 409:main.c        **** 	my_eeprom_busy_wait();
 183               	.LM16:
 184 0080 8FB3      		in r24,63-0x20
 185 0082 9927      		clr r25
 186 0084 9695      		lsr r25
 187 0086 8795      		ror r24
 188 0088 AC01      		movw r20,r24
 189 008a 4170      		andi r20,lo8(1)
 190 008c 5070      		andi r21,hi8(1)
 191 008e 80FD      		sbrc r24,0
 192 0090 F7CF      		rjmp .L9
 410:main.c        **** 	
 411:main.c        **** 	if (device == devtype)
 194               	.LM17:
 195 0092 8091 0000 		lds r24,device
 196 0096 8537      		cpi r24,lo8(117)
 197 0098 09F0      		breq .+2
 198 009a 7FC0      		rjmp .L12
 412:main.c        **** 	{
 413:main.c        **** 		if (mem == 'F')		// Flash
 200               	.LM18:
 201 009c 86E4      		ldi r24,lo8(70)
 202 009e B816      		cp r11,r24
 203 00a0 09F0      		breq .+2
 204 00a2 39C0      		rjmp .L13
 205 00a4 41E0      		ldi r20,lo8(1)
 206 00a6 C0E0      		ldi r28,lo8(gBuffer)
 207 00a8 D0E0      		ldi r29,hi8(gBuffer)
 208               	.L14:
 414:main.c        **** 		{
 415:main.c        **** 			do {
 416:main.c        **** 				data=gBuffer[cnt++];
 210               	.LM19:
 211 00aa 8991      		ld r24,Y+
 212 00ac 282F      		mov r18,r24
 213 00ae 3327      		clr r19
 417:main.c        **** 				data|=(gBuffer[cnt++]<<8);
 215               	.LM20:
 216 00b0 8991      		ld r24,Y+
 217 00b2 9927      		clr r25
 218 00b4 982F      		mov r25,r24
 219 00b6 8827      		clr r24
 220 00b8 282B      		or r18,r24
 221 00ba 392B      		or r19,r25
 222               	.LBB2:
 418:main.c        **** 				boot_page_fill(address,data);
 224               	.LM21:
 225 00bc 8091 0000 		lds r24,address
 226 00c0 9091 0000 		lds r25,(address)+1
 227               	/* #APP */
 228 00c4 0901      		movw  r0, r18
 229 00c6 FC01      		movw r30, r24
 230 00c8 4093 5700 		sts 87, r20
 231 00cc E895      		spm
 232 00ce 1124      		clr  r1
 233               		
 234               	/* #NOAPP */
 235               	.LBE2:
 419:main.c        **** 											//call asm routine. 
 420:main.c        **** 				address=address+2;  		// Select next word in memory
 237               	.LM22:
 238 00d0 8091 0000 		lds r24,address
 239 00d4 9091 0000 		lds r25,(address)+1
 240 00d8 A091 0000 		lds r26,(address)+2
 241 00dc B091 0000 		lds r27,(address)+3
 242 00e0 0296      		adiw r24,2
 243 00e2 A11D      		adc r26,__zero_reg__
 244 00e4 B11D      		adc r27,__zero_reg__
 245 00e6 8093 0000 		sts address,r24
 246 00ea 9093 0000 		sts (address)+1,r25
 247 00ee A093 0000 		sts (address)+2,r26
 248 00f2 B093 0000 		sts (address)+3,r27
 421:main.c        **** 				size -= 2;					// Reduce number of bytes to write by two    
 250               	.LM23:
 251 00f6 0250      		subi r16,lo8(-(-2))
 252 00f8 1040      		sbci r17,hi8(-(-2))
 422:main.c        **** 			} while(size);					// Loop until all bytes written
 254               	.LM24:
 255 00fa B9F6      		brne .L14
 256               	.LBB3:
 423:main.c        **** 
 424:main.c        **** 			/* commented out since not compatible with mega8 - 
 425:main.c        **** 			   secondary benefit: saves memory 
 426:main.c        **** 			tempaddress &= 0xFF80;			// Ensure the address points to the first byte in the page
 427:main.c        **** 			*/
 428:main.c        **** 
 429:main.c        **** 			boot_page_write(tempaddress);
 258               	.LM25:
 259 00fc 85E0      		ldi r24,lo8(5)
 260               	/* #APP */
 261 00fe F601      		movw r30, r12
 262 0100 8093 5700 		sts 87, r24
 263 0104 E895      		spm
 264               		
 265               	/* #NOAPP */
 266               	.L17:
 267               	.LBE3:
 430:main.c        **** 			boot_spm_busy_wait();	
 269               	.LM26:
 270 0106 07B6      		in __tmp_reg__,87-0x20
 271 0108 00FC      		sbrc __tmp_reg__,0
 272 010a FDCF      		rjmp .L17
 273               	.LBB4:
 431:main.c        **** 			boot_rww_enable();				//Re-enable the RWW section
 275               	.LM27:
 276 010c 81E1      		ldi r24,lo8(17)
 277               	/* #APP */
 278 010e 8093 5700 		sts 87, r24
 279 0112 E895      		spm
 280               		
 281               	/* #NOAPP */
 282 0114 3FC0      		rjmp .L20
 283               	.L13:
 284               	.LBE4:
 432:main.c        **** 			
 433:main.c        **** 			/* commented out since not compatible with mega8
 434:main.c        **** 			if (address != (address & 0xFF80))
 435:main.c        **** 			{								// Ensure that the address points to the beginning of the next page
 436:main.c        **** 				address &= 0xFF80;
 437:main.c        **** 				address += SPM_PAGESIZE;
 438:main.c        **** 			}
 439:main.c        **** 			*/	
 440:main.c        **** 		}									// End FLASH
 441:main.c        **** 		
 442:main.c        **** 		if (mem == 'E')						// Start EEPROM
 286               	.LM28:
 287 0116 85E4      		ldi r24,lo8(69)
 288 0118 B816      		cp r11,r24
 289 011a E1F5      		brne .L20
 443:main.c        ****         {
 444:main.c        **** 			address>>=1;
 291               	.LM29:
 292 011c 8091 0000 		lds r24,address
 293 0120 9091 0000 		lds r25,(address)+1
 294 0124 A091 0000 		lds r26,(address)+2
 295 0128 B091 0000 		lds r27,(address)+3
 296 012c B695      		lsr r27
 297 012e A795      		ror r26
 298 0130 9795      		ror r25
 299 0132 8795      		ror r24
 300 0134 8093 0000 		sts address,r24
 301 0138 9093 0000 		sts (address)+1,r25
 302 013c A093 0000 		sts (address)+2,r26
 303 0140 B093 0000 		sts (address)+3,r27
 304 0144 F901      		movw r30,r18
 305 0146 E050      		subi r30,lo8(-(gBuffer-1))
 306 0148 F040      		sbci r31,hi8(-(gBuffer-1))
 307               	.L21:
 445:main.c        **** 			do {
 446:main.c        **** 	 	        EEARL = address;			// Setup EEPROM address
 309               	.LM30:
 310 014a 8091 0000 		lds r24,address
 311 014e 81BD      		out 65-0x20,r24
 447:main.c        **** 	            EEARH = (address >> 8);
 313               	.LM31:
 314 0150 8091 0000 		lds r24,address
 315 0154 9091 0000 		lds r25,(address)+1
 316 0158 A091 0000 		lds r26,(address)+2
 317 015c B091 0000 		lds r27,(address)+3
 318 0160 292F      		mov r18,r25
 319 0162 3A2F      		mov r19,r26
 320 0164 4B2F      		mov r20,r27
 321 0166 5527      		clr r21
 322 0168 22BD      		out 66-0x20,r18
 448:main.c        **** 				address++;					// Select next byte
 324               	.LM32:
 325 016a 0196      		adiw r24,1
 326 016c A11D      		adc r26,__zero_reg__
 327 016e B11D      		adc r27,__zero_reg__
 328 0170 8093 0000 		sts address,r24
 329 0174 9093 0000 		sts (address)+1,r25
 330 0178 A093 0000 		sts (address)+2,r26
 331 017c B093 0000 		sts (address)+3,r27
 449:main.c        **** 				EEDR=gBuffer[cnt++];
 333               	.LM33:
 334 0180 3196      		adiw r30,1
 335 0182 8081      		ld r24,Z
 336 0184 80BD      		out 64-0x20,r24
 450:main.c        **** 				
 451:main.c        **** 	            EECR |= (1<<EEMWE);			// Write data into EEPROM
 338               	.LM34:
 339 0186 FA9A      		sbi 63-0x20,2
 452:main.c        **** 	            EECR |= (1<<EEWE);
 341               	.LM35:
 342 0188 F99A      		sbi 63-0x20,1
 343               	.L24:
 453:main.c        **** 	            
 454:main.c        **** 				while (EECR & (1<<EEWE));	// Wait for EEPROM write to finish
 345               	.LM36:
 346 018a F999      		sbic 63-0x20,1
 347 018c FECF      		rjmp .L24
 455:main.c        **** 				size--;						// Decreas number of bytes to write
 349               	.LM37:
 350 018e 0150      		subi r16,lo8(-(-1))
 351 0190 1040      		sbci r17,hi8(-(-1))
 456:main.c        **** 			} while(size);					// Loop until all bytes written
 353               	.LM38:
 354 0192 D9F6      		brne .L21
 355               	.L20:
 457:main.c        **** 
 458:main.c        **** 		}
 459:main.c        **** 
 460:main.c        **** 		return '\r';						// Report programming OK
 357               	.LM39:
 358 0194 8DE0      		ldi r24,lo8(13)
 359 0196 90E0      		ldi r25,hi8(13)
 360 0198 01C0      		rjmp .L2
 361               	.L12:
 461:main.c        **** 
 462:main.c        **** 	}
 463:main.c        **** 	
 464:main.c        **** 	return 0;								// Report programming failed
 363               	.LM40:
 364 019a CA01      		movw r24,r20
 365               	.L2:
 366               	/* epilogue: frame size=0 */
 367 019c DF91      		pop r29
 368 019e CF91      		pop r28
 369 01a0 1F91      		pop r17
 370 01a2 0F91      		pop r16
 371 01a4 FF90      		pop r15
 372 01a6 EF90      		pop r14
 373 01a8 DF90      		pop r13
 374 01aa CF90      		pop r12
 375 01ac BF90      		pop r11
 376 01ae 0895      		ret
 377               	/* epilogue end (size=10) */
 378               	/* function BufferLoad size 211 (192) */
 385               	.Lscope1:
 389               	.global	BlockRead
 391               	BlockRead:
 465:main.c        **** }
 466:main.c        **** 
 467:main.c        **** void BlockRead(unsigned int size, unsigned char mem)
 468:main.c        **** {
 393               	.LM41:
 394               	/* prologue: frame size=0 */
 395 01b0 0F93      		push r16
 396 01b2 1F93      		push r17
 397 01b4 CF93      		push r28
 398 01b6 DF93      		push r29
 399               	/* prologue end (size=4) */
 400 01b8 EC01      		movw r28,r24
 401               	.L31:
 469:main.c        **** 	unsigned int data;
 470:main.c        **** 	
 471:main.c        **** 	my_eeprom_busy_wait();
 403               	.LM42:
 404 01ba F999      		sbic 63-0x20,1
 405 01bc FECF      		rjmp .L31
 472:main.c        **** 	
 473:main.c        **** 	if (mem == 'E')							// Read EEPROM
 407               	.LM43:
 408 01be 6534      		cpi r22,lo8(69)
 409 01c0 11F5      		brne .L39
 410               	.L35:
 474:main.c        **** 	{
 475:main.c        **** 		// address>>=1; // not needed here - hmm, somehow inconsistant TODO
 476:main.c        **** 		do {
 477:main.c        **** 			EEARL = address;				// Setup EEPROM address
 412               	.LM44:
 413 01c2 8091 0000 		lds r24,address
 414 01c6 81BD      		out 65-0x20,r24
 478:main.c        **** 			EEARH = (address >> 8);
 416               	.LM45:
 417 01c8 8091 0000 		lds r24,address
 418 01cc 9091 0000 		lds r25,(address)+1
 419 01d0 A091 0000 		lds r26,(address)+2
 420 01d4 B091 0000 		lds r27,(address)+3
 421 01d8 292F      		mov r18,r25
 422 01da 3A2F      		mov r19,r26
 423 01dc 4B2F      		mov r20,r27
 424 01de 5527      		clr r21
 425 01e0 22BD      		out 66-0x20,r18
 479:main.c        **** 			address++;						// Select next EEPROM byte
 427               	.LM46:
 428 01e2 0196      		adiw r24,1
 429 01e4 A11D      		adc r26,__zero_reg__
 430 01e6 B11D      		adc r27,__zero_reg__
 431 01e8 8093 0000 		sts address,r24
 432 01ec 9093 0000 		sts (address)+1,r25
 433 01f0 A093 0000 		sts (address)+2,r26
 434 01f4 B093 0000 		sts (address)+3,r27
 480:main.c        **** 			EECR |= (1<<EERE);				// Read EEPROM
 436               	.LM47:
 437 01f8 F89A      		sbi 63-0x20,0
 481:main.c        **** 			sendchar(EEDR);					// Transmit EEPROM data to PC
 439               	.LM48:
 440 01fa 80B5      		in r24,64-0x20
 441 01fc 0E94 0000 		call sendchar
 482:main.c        **** 			size--;							// Decrease number of bytes to read
 443               	.LM49:
 444 0200 2197      		sbiw r28,1
 483:main.c        **** 		} while (size);					// Repeat until all block has been read
 446               	.LM50:
 447 0202 F9F6      		brne .L35
 448 0204 22C0      		rjmp .L30
 449               	.L39:
 450               	.LBB5:
 484:main.c        **** 	}
 485:main.c        **** 	else									// Read Flash
 486:main.c        **** 	{
 487:main.c        **** 		do {
 488:main.c        **** #if defined(RAMPZ)
 489:main.c        **** 			data = pgm_read_word_far(address);
 490:main.c        **** #else
 491:main.c        **** 			data = pgm_read_word_near((uint16_t)address);
 452               	.LM51:
 453 0206 E091 0000 		lds r30,address
 454 020a F091 0000 		lds r31,(address)+1
 455               	/* #APP */
 456 020e 0591      		lpm r16, Z+
 457 0210 1491      		lpm r17, Z
 458               		
 459               	/* #NOAPP */
 460               	.LBE5:
 492:main.c        **** #endif
 493:main.c        **** 			sendchar((unsigned char)data);		//send LSB
 462               	.LM52:
 463 0212 802F      		mov r24,r16
 464 0214 0E94 0000 		call sendchar
 494:main.c        **** 			sendchar((unsigned char)(data >> 8));	//send MSB  
 466               	.LM53:
 467 0218 812F      		mov r24,r17
 468 021a 9927      		clr r25
 469 021c 0E94 0000 		call sendchar
 495:main.c        **** 			address += 2;  					// Select next word in memory
 471               	.LM54:
 472 0220 8091 0000 		lds r24,address
 473 0224 9091 0000 		lds r25,(address)+1
 474 0228 A091 0000 		lds r26,(address)+2
 475 022c B091 0000 		lds r27,(address)+3
 476 0230 0296      		adiw r24,2
 477 0232 A11D      		adc r26,__zero_reg__
 478 0234 B11D      		adc r27,__zero_reg__
 479 0236 8093 0000 		sts address,r24
 480 023a 9093 0000 		sts (address)+1,r25
 481 023e A093 0000 		sts (address)+2,r26
 482 0242 B093 0000 		sts (address)+3,r27
 496:main.c        **** 			size -= 2;						// Subtract two bytes from number of bytes to read
 484               	.LM55:
 485 0246 2297      		sbiw r28,2
 497:main.c        **** 		} while (size);					// Repeat until all block has been read
 487               	.LM56:
 488 0248 F1F6      		brne .L39
 489               	.L30:
 490               	/* epilogue: frame size=0 */
 491 024a DF91      		pop r29
 492 024c CF91      		pop r28
 493 024e 1F91      		pop r17
 494 0250 0F91      		pop r16
 495 0252 0895      		ret
 496               	/* epilogue end (size=5) */
 497               	/* function BlockRead size 88 (79) */
 503               	.Lscope2:
 505               	.global	main
 507               	main:
 509               	.LM57:
 510               	/* prologue: frame size=0 */
 511 0254 C0E0      		ldi r28,lo8(__stack - 0)
 512 0256 D0E0      		ldi r29,hi8(__stack - 0)
 513 0258 DEBF      		out __SP_H__,r29
 514 025a CDBF      		out __SP_L__,r28
 515               	/* prologue end (size=4) */
 517               	.LM58:
 518               	/* #APP */
 519 025c F894      		cli
 521               	.LM59:
 522               	/* #NOAPP */
 523 025e 81E0      		ldi r24,lo8(1)
 524 0260 85BF      		out 85-0x20,r24
 526               	.LM60:
 527 0262 82E0      		ldi r24,lo8(2)
 528 0264 85BF      		out 85-0x20,r24
 530               	.LM61:
 531 0266 60E0      		ldi r22,lo8(0)
 532 0268 89E1      		ldi r24,lo8(25)
 533 026a 90E0      		ldi r25,hi8(25)
 534 026c 0E94 0000 		call USART_Init
 536               	.LM62:
 537 0270 3898      		cbi 39-0x20,0
 539               	.LM63:
 540 0272 409A      		sbi 40-0x20,0
 541               	.L100:
 543               	.LM64:
 544 0274 0E94 0000 		call recchar
 545 0278 682F      		mov r22,r24
 547               	.LM65:
 548 027a 8136      		cpi r24,lo8(97)
 549 027c 11F4      		brne .L45
 551               	.LM66:
 552 027e 89E5      		ldi r24,lo8(89)
 553 0280 F1C0      		rjmp .L97
 554               	.L45:
 556               	.LM67:
 557 0282 8134      		cpi r24,lo8(65)
 558 0284 39F5      		brne .L47
 560               	.LM68:
 561 0286 0E94 0000 		call recchar
 562 028a 9927      		clr r25
 563 028c AA27      		clr r26
 564 028e BB27      		clr r27
 565 0290 8093 0000 		sts address,r24
 566 0294 9093 0000 		sts (address)+1,r25
 567 0298 A093 0000 		sts (address)+2,r26
 568 029c B093 0000 		sts (address)+3,r27
 570               	.LM69:
 571 02a0 EE24      		clr r14
 572 02a2 F82E      		mov r15,r24
 573 02a4 092F      		mov r16,r25
 574 02a6 1A2F      		mov r17,r26
 575 02a8 0E94 0000 		call recchar
 576 02ac 9927      		clr r25
 577 02ae AA27      		clr r26
 578 02b0 BB27      		clr r27
 579 02b2 E82A      		or r14,r24
 580 02b4 F92A      		or r15,r25
 581 02b6 0A2B      		or r16,r26
 582 02b8 1B2B      		or r17,r27
 584               	.LM70:
 585 02ba EE0C      		lsl r14
 586 02bc FF1C      		rol r15
 587 02be 001F      		rol r16
 588 02c0 111F      		rol r17
 589 02c2 E092 0000 		sts address,r14
 590 02c6 F092 0000 		sts (address)+1,r15
 591 02ca 0093 0000 		sts (address)+2,r16
 592 02ce 1093 0000 		sts (address)+3,r17
 593 02d2 68C0      		rjmp .L98
 594               	.L47:
 596               	.LM71:
 597 02d4 8236      		cpi r24,lo8(98)
 598 02d6 41F4      		brne .L49
 600               	.LM72:
 601 02d8 89E5      		ldi r24,lo8(89)
 602 02da 0E94 0000 		call sendchar
 604               	.LM73:
 605 02de 80E0      		ldi r24,lo8(0)
 606 02e0 0E94 0000 		call sendchar
 608               	.LM74:
 609 02e4 80E8      		ldi r24,lo8(-128)
 610 02e6 BEC0      		rjmp .L97
 611               	.L49:
 613               	.LM75:
 614 02e8 8234      		cpi r24,lo8(66)
 615 02ea 89F4      		brne .L51
 617               	.LM76:
 618 02ec 0E94 0000 		call recchar
 619 02f0 9927      		clr r25
 620 02f2 182F      		mov r17,r24
 621 02f4 0027      		clr r16
 623               	.LM77:
 624 02f6 0E94 0000 		call recchar
 625 02fa 9927      		clr r25
 626 02fc 082B      		or r16,r24
 627 02fe 192B      		or r17,r25
 629               	.LM78:
 630 0300 0E94 0000 		call recchar
 631 0304 682F      		mov r22,r24
 633               	.LM79:
 634 0306 C801      		movw r24,r16
 635 0308 0E94 0000 		call BufferLoad
 636 030c ABC0      		rjmp .L97
 637               	.L51:
 639               	.LM80:
 640 030e 8736      		cpi r24,lo8(103)
 641 0310 89F4      		brne .L53
 643               	.LM81:
 644 0312 0E94 0000 		call recchar
 645 0316 9927      		clr r25
 646 0318 182F      		mov r17,r24
 647 031a 0027      		clr r16
 648 031c 0E94 0000 		call recchar
 649 0320 9927      		clr r25
 650 0322 082B      		or r16,r24
 651 0324 192B      		or r17,r25
 653               	.LM82:
 654 0326 0E94 0000 		call recchar
 655 032a 682F      		mov r22,r24
 657               	.LM83:
 658 032c C801      		movw r24,r16
 659 032e 0E94 0000 		call BlockRead
 660 0332 A0CF      		rjmp .L100
 661               	.L53:
 663               	.LM84:
 664 0334 8536      		cpi r24,lo8(101)
 665 0336 09F0      		breq .+2
 666 0338 37C0      		rjmp .L55
 668               	.LM85:
 669 033a 8091 0000 		lds r24,device
 670 033e 8537      		cpi r24,lo8(117)
 671 0340 69F5      		brne .L56
 673               	.LM86:
 674 0342 1092 0000 		sts address,__zero_reg__
 675 0346 1092 0000 		sts (address)+1,__zero_reg__
 676 034a 1092 0000 		sts (address)+2,__zero_reg__
 677 034e 1092 0000 		sts (address)+3,__zero_reg__
 678 0352 23E0      		ldi r18,lo8(3)
 679               	.L62:
 680               	.LBB6:
 682               	.LM87:
 683 0354 8091 0000 		lds r24,address
 684 0358 9091 0000 		lds r25,(address)+1
 685               	/* #APP */
 686 035c FC01      		movw r30, r24
 687 035e 2093 5700 		sts 87, r18
 688 0362 E895      		spm
 689               		
 690               	/* #NOAPP */
 691               	.L59:
 692               	.LBE6:
 694               	.LM88:
 695 0364 07B6      		in __tmp_reg__,87-0x20
 696 0366 00FC      		sbrc __tmp_reg__,0
 697 0368 FDCF      		rjmp .L59
 699               	.LM89:
 700 036a 8091 0000 		lds r24,address
 701 036e 9091 0000 		lds r25,(address)+1
 702 0372 A091 0000 		lds r26,(address)+2
 703 0376 B091 0000 		lds r27,(address)+3
 704 037a 8058      		subi r24,lo8(-(128))
 705 037c 9F4F      		sbci r25,hi8(-(128))
 706 037e AF4F      		sbci r26,hlo8(-(128))
 707 0380 BF4F      		sbci r27,hhi8(-(128))
 708 0382 8093 0000 		sts address,r24
 709 0386 9093 0000 		sts (address)+1,r25
 710 038a A093 0000 		sts (address)+2,r26
 711 038e B093 0000 		sts (address)+3,r27
 712 0392 8050      		subi r24,lo8(14336)
 713 0394 9843      		sbci r25,hi8(14336)
 714 0396 A040      		sbci r26,hlo8(14336)
 715 0398 B040      		sbci r27,hhi8(14336)
 716 039a E0F2      		brlo .L62
 717               	.L56:
 718               	.LBB7:
 720               	.LM90:
 721 039c 81E1      		ldi r24,lo8(17)
 722               	/* #APP */
 723 039e 8093 5700 		sts 87, r24
 724 03a2 E895      		spm
 725               		
 726               	/* #NOAPP */
 727               	.L98:
 728               	.LBE7:
 730               	.LM91:
 731 03a4 8DE0      		ldi r24,lo8(13)
 732 03a6 5EC0      		rjmp .L97
 733               	.L55:
 735               	.LM92:
 736 03a8 8534      		cpi r24,lo8(69)
 737 03aa 61F4      		brne .L64
 739               	.LM93:
 740 03ac 88E1      		ldi r24,lo8(24)
 741 03ae 90E0      		ldi r25,hi8(24)
 742 03b0 28E0      		ldi r18,lo8(8)
 743               	/* #APP */
 744 03b2 0FB6      		in __tmp_reg__,__SREG__
 745 03b4 F894      		cli
 746 03b6 A895      		wdr
 747 03b8 8093 6000 		sts 96,r24
 748 03bc 0FBE      		out __SREG__,__tmp_reg__
 749 03be 2093 6000 		sts 96,r18
 750               	/* #NOAPP */
 751 03c2 F0CF      		rjmp .L98
 752               	.L64:
 754               	.LM94:
 755 03c4 8035      		cpi r24,lo8(80)
 756 03c6 71F3      		breq .L98
 758               	.LM95:
 759 03c8 8C34      		cpi r24,lo8(76)
 760 03ca 61F3      		breq .L98
 762               	.LM96:
 763 03cc 8037      		cpi r24,lo8(112)
 764 03ce 11F4      		brne .L70
 766               	.LM97:
 767 03d0 83E5      		ldi r24,lo8(83)
 768 03d2 48C0      		rjmp .L97
 769               	.L70:
 771               	.LM98:
 772 03d4 8634      		cpi r24,lo8(70)
 773 03d6 21F4      		brne .L72
 775               	.LM99:
 776 03d8 69E0      		ldi r22,lo8(9)
 777 03da 80E0      		ldi r24,lo8(0)
 778 03dc 90E0      		ldi r25,hi8(0)
 779 03de 05C0      		rjmp .L99
 780               	.L72:
 782               	.LM100:
 783 03e0 8237      		cpi r24,lo8(114)
 784 03e2 31F4      		brne .L74
 786               	.LM101:
 787 03e4 69E0      		ldi r22,lo8(9)
 788 03e6 81E0      		ldi r24,lo8(1)
 789 03e8 90E0      		ldi r25,hi8(1)
 790               	.L99:
 791 03ea 0E94 0000 		call read_fuse_lock
 792 03ee 3AC0      		rjmp .L97
 793               	.L74:
 795               	.LM102:
 796 03f0 8E34      		cpi r24,lo8(78)
 797 03f2 21F4      		brne .L76
 799               	.LM103:
 800 03f4 69E0      		ldi r22,lo8(9)
 801 03f6 83E0      		ldi r24,lo8(3)
 802 03f8 90E0      		ldi r25,hi8(3)
 803 03fa F7CF      		rjmp .L99
 804               	.L76:
 806               	.LM104:
 807 03fc 8135      		cpi r24,lo8(81)
 808 03fe 21F4      		brne .L78
 810               	.LM105:
 811 0400 69E0      		ldi r22,lo8(9)
 812 0402 82E0      		ldi r24,lo8(2)
 813 0404 90E0      		ldi r25,hi8(2)
 814 0406 F1CF      		rjmp .L99
 815               	.L78:
 817               	.LM106:
 818 0408 8437      		cpi r24,lo8(116)
 819 040a 29F4      		brne .L80
 821               	.LM107:
 822 040c 85E7      		ldi r24,lo8(117)
 823 040e 0E94 0000 		call sendchar
 825               	.LM108:
 826 0412 80E0      		ldi r24,lo8(0)
 827 0414 27C0      		rjmp .L97
 828               	.L80:
 830               	.LM109:
 831 0416 8857      		subi r24,lo8(-(-120))
 832 0418 8230      		cpi r24,lo8(2)
 833 041a 18F4      		brsh .L82
 835               	.LM110:
 836 041c 0E94 0000 		call recchar
 837 0420 C1CF      		rjmp .L98
 838               	.L82:
 840               	.LM111:
 841 0422 6435      		cpi r22,lo8(84)
 842 0424 29F4      		brne .L84
 844               	.LM112:
 845 0426 0E94 0000 		call recchar
 846 042a 8093 0000 		sts device,r24
 847 042e BACF      		rjmp .L98
 848               	.L84:
 850               	.LM113:
 851 0430 6335      		cpi r22,lo8(83)
 852 0432 19F4      		brne .L86
 854               	.LM114:
 855 0434 0E94 0000 		call send_boot
 856 0438 1DCF      		rjmp .L100
 857               	.L86:
 859               	.LM115:
 860 043a 6635      		cpi r22,lo8(86)
 861 043c 29F4      		brne .L88
 863               	.LM116:
 864 043e 80E3      		ldi r24,lo8(48)
 865 0440 0E94 0000 		call sendchar
 867               	.LM117:
 868 0444 87E3      		ldi r24,lo8(55)
 869 0446 0EC0      		rjmp .L97
 870               	.L88:
 872               	.LM118:
 873 0448 6337      		cpi r22,lo8(115)
 874 044a 41F4      		brne .L90
 876               	.LM119:
 877 044c 86E0      		ldi r24,lo8(6)
 878 044e 0E94 0000 		call sendchar
 880               	.LM120:
 881 0452 84E9      		ldi r24,lo8(-108)
 882 0454 0E94 0000 		call sendchar
 884               	.LM121:
 885 0458 8EE1      		ldi r24,lo8(30)
 886 045a 04C0      		rjmp .L97
 887               	.L90:
 889               	.LM122:
 890 045c 6B31      		cpi r22,lo8(27)
 891 045e 09F4      		brne .+2
 892 0460 09CF      		rjmp .L100
 894               	.LM123:
 895 0462 8FE3      		ldi r24,lo8(63)
 896               	.L97:
 897 0464 0E94 0000 		call sendchar
 899               	.LM124:
 900 0468 05CF      		rjmp .L100
 901               	/* epilogue: frame size=0 */
 902               	/* epilogue: noreturn */
 903               	/* epilogue end (size=0) */
 904               	/* function main size 282 (278) */
 910               	.Lscope3:
 911               		.comm gBuffer,128,1
 912               		.comm address,4,1
 913               		.comm device,1,1
 918               		.text
 920               	Letext:
 921               	/* File "main.c": code  603 = 0x025b ( 570), prologues  17, epilogues  16 */
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
C:\DOCUME~1\JVANAA~1\LOCALS~1\Temp/cco7aaaa.s:74     .bss:00000000 jump_to_app
C:\DOCUME~1\JVANAA~1\LOCALS~1\Temp/cco7aaaa.s:80     .text:00000000 send_boot
C:\DOCUME~1\JVANAA~1\LOCALS~1\Temp/cco7aaaa.s:124    .text:0000002c BufferLoad
                            *COM*:00000080 gBuffer
                            *COM*:00000004 address
                            *COM*:00000001 device
C:\DOCUME~1\JVANAA~1\LOCALS~1\Temp/cco7aaaa.s:391    .text:000001b0 BlockRead
C:\DOCUME~1\JVANAA~1\LOCALS~1\Temp/cco7aaaa.s:507    .text:00000254 main
C:\DOCUME~1\JVANAA~1\LOCALS~1\Temp/cco7aaaa.s:920    .text:0000046a Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
sendchar
recchar
__stack
USART_Init
read_fuse_lock
