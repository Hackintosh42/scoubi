<AVRPART><MODULE_LIST>[ADMIN:CORE:INTERRUPT_VECTOR:POWER:PROGVOLT:PACKAGE:MEMORY:IO_MODULE:ICE_SETTINGS]</MODULE_LIST><ADMIN>
		<PART_NAME>ATtiny2313</PART_NAME>
		<SPEED>16MHZ</SPEED>
		<BUILD>64</BUILD>
		<RELEASE_STATUS>RELEASED</RELEASE_STATUS>
		<SIGNATURE>
			<ADDR000>$1E</ADDR000>
			<ADDR001>$91</ADDR001>
			<ADDR002>$0A</ADDR002>
		</SIGNATURE>
	</ADMIN>
	<CORE>
		<CORE_VERSION>V1</CORE_VERSION>
		<ID>AVRSimCoreV1.SimCoreV1</ID>
		<NEW_INSTRUCTIONS>[]</NEW_INSTRUCTIONS>
		<INSTRUCTIONS_NOT_SUPPORTED>[]</INSTRUCTIONS_NOT_SUPPORTED>
		<RAMP_REGISTERS>[0x0023:0x0034:0x0054]</RAMP_REGISTERS>
		<GP_REG_FILE>
			<NMB_REG>32</NMB_REG>
			<START_ADDR>$00</START_ADDR>
			<X_REG_HIGH>$1B</X_REG_HIGH>
			<X_REG_LOW>$1A</X_REG_LOW>
			<Y_REG_HIGH>$1D</Y_REG_HIGH>
			<Y_REG_LOW>$1C</Y_REG_LOW>
			<Z_REG_HIGH>$1F</Z_REG_HIGH>
			<Z_REG_LOW>$1E</Z_REG_LOW>
		</GP_REG_FILE>
	</CORE>
	<INTERRUPT_VECTOR>
		<NMB_VECTORS>19</NMB_VECTORS>
		<VECTOR1>
			<PROGRAM_ADDRESS>$000</PROGRAM_ADDRESS>
			<SOURCE>RESET</SOURCE>
			<DEFINITION>External Reset, Power-on Reset and Watchdog Reset</DEFINITION>
		</VECTOR1>
		<VECTOR2>
			<PROGRAM_ADDRESS>$001</PROGRAM_ADDRESS>
			<SOURCE>INT0</SOURCE>
			<DEFINITION>External Interrupt Request 0</DEFINITION>
		</VECTOR2>
		<VECTOR3>
			<PROGRAM_ADDRESS>$002</PROGRAM_ADDRESS>
			<SOURCE>INT1</SOURCE>
			<DEFINITION>External Interrupt Request 1</DEFINITION>
		</VECTOR3>
		<VECTOR4>
			<PROGRAM_ADDRESS>$003</PROGRAM_ADDRESS>
			<SOURCE>TIMER1 CAPT</SOURCE>
			<DEFINITION>Timer/Counter1 Capture Event</DEFINITION>
		</VECTOR4>
		<VECTOR5>
			<PROGRAM_ADDRESS>$004</PROGRAM_ADDRESS>
			<SOURCE>TIMER1 COMPA</SOURCE>
			<DEFINITION>Timer/Counter1 Compare Match A</DEFINITION>
		</VECTOR5>
		<VECTOR6>
			<PROGRAM_ADDRESS>$005</PROGRAM_ADDRESS>
			<SOURCE>TIMER1 OVF</SOURCE>
			<DEFINITION>Timer/Counter1 Overflow</DEFINITION>
		</VECTOR6>
		<VECTOR7>
			<PROGRAM_ADDRESS>$006</PROGRAM_ADDRESS>
			<SOURCE>TIMER0 OVF</SOURCE>
			<DEFINITION>Timer/Counter0 Overflow</DEFINITION>
		</VECTOR7>
		<VECTOR8>
			<PROGRAM_ADDRESS>$007</PROGRAM_ADDRESS>
			<SOURCE>USART, RX</SOURCE>
			<DEFINITION>USART, Rx Complete</DEFINITION>
		</VECTOR8>
		<VECTOR9>
			<PROGRAM_ADDRESS>$008</PROGRAM_ADDRESS>
			<SOURCE>USART, UDRE</SOURCE>
			<DEFINITION>USART Data Register Empty</DEFINITION>
		</VECTOR9>
		<VECTOR10>
			<PROGRAM_ADDRESS>$009</PROGRAM_ADDRESS>
			<SOURCE>USART, TX</SOURCE>
			<DEFINITION>USART, Tx Complete</DEFINITION>
		</VECTOR10>
		<VECTOR11>
			<PROGRAM_ADDRESS>$00A</PROGRAM_ADDRESS>
			<SOURCE>ANA COMP</SOURCE>
			<DEFINITION>Analog Comparator</DEFINITION>
		</VECTOR11>
		<VECTOR12>
			<PROGRAM_ADDRESS>$00B</PROGRAM_ADDRESS>
			<SOURCE>PCINT</SOURCE>
			<DEFINITION/>
		</VECTOR12>
		<VECTOR13>
			<PROGRAM_ADDRESS>$00C</PROGRAM_ADDRESS>
			<SOURCE>TIMER1 COMPB</SOURCE>
			<DEFINITION/>
		</VECTOR13>
		<VECTOR14>
			<PROGRAM_ADDRESS>$00D</PROGRAM_ADDRESS>
			<SOURCE>TIMER0 COMPA</SOURCE>
			<DEFINITION/>
		</VECTOR14>
		<VECTOR15>
			<PROGRAM_ADDRESS>$00E</PROGRAM_ADDRESS>
			<SOURCE>TIMER0 COMPB</SOURCE>
			<DEFINITION/>
		</VECTOR15>
		<VECTOR16>
			<PROGRAM_ADDRESS>$00F</PROGRAM_ADDRESS>
			<SOURCE>USI Start Condition</SOURCE>
			<DEFINITION/>
		</VECTOR16>
		<VECTOR17>
			<PROGRAM_ADDRESS>$010</PROGRAM_ADDRESS>
			<SOURCE>USI Overflow</SOURCE>
			<DEFINITION/>
		</VECTOR17>
		<VECTOR18>
			<PROGRAM_ADDRESS>$11</PROGRAM_ADDRESS>
			<SOURCE>EEPROM Ready</SOURCE>
			<DEFINITION/>
		</VECTOR18>
		<VECTOR19>
			<PROGRAM_ADDRESS>$012</PROGRAM_ADDRESS>
			<SOURCE>Watchdog Timer Overflow</SOURCE>
			<DEFINITION/>
		</VECTOR19>
	</INTERRUPT_VECTOR>
	<POWER>
		<CLOCK>4MHz</CLOCK>
		<TEMP>25C</TEMP>
		<ACTIVE>2.8mA</ACTIVE>
		<IDLE>0.8mA</IDLE>
		<POWER_DOWN>&lt;1uA</POWER_DOWN>
	</POWER>
	<PROGVOLT>
		<SER_PROG_MIN_V>2.7</SER_PROG_MIN_V>
		<SER_PROG_MAX_V>6.0</SER_PROG_MAX_V>
		<PAR_PROG_MIN_V>4.0</PAR_PROG_MIN_V>
		<PAR_PROG_MAX_V>6.0</PAR_PROG_MAX_V>
	</PROGVOLT>
	<PACKAGE>
		<PACKAGES>[DIP:SOIC]</PACKAGES>
		<DIP>
			<NMB_PIN>20</NMB_PIN>
			<PIN1>
				<NAME>['RESET]</NAME>
				<TEXT/>
			</PIN1>
			<PIN2>
				<NAME>[PD0:RXD]</NAME>
				<TEXT/>
			</PIN2>
			<PIN3>
				<NAME>[PD1:TXD]</NAME>
				<TEXT/>
			</PIN3>
			<PIN4>
				<NAME>[XTAL2:PA1]</NAME>
				<TEXT/>
			</PIN4>
			<PIN5>
				<NAME>[XTAL1:PA0]</NAME>
				<TEXT/>
			</PIN5>
			<PIN6>
				<NAME>[PD2:INT0:XCK:CKOUT]</NAME>
				<TEXT/>
			</PIN6>
			<PIN7>
				<NAME>[PD3:INT1]</NAME>
				<TEXT/>
			</PIN7>
			<PIN8>
				<NAME>[PD4:T0]</NAME>
				<TEXT/>
			</PIN8>
			<PIN9>
				<NAME>[PD5:T1:OC0B]</NAME>
				<TEXT/>
			</PIN9>
			<PIN10>
				<NAME>[GND]</NAME>
				<TEXT/>
			</PIN10>
			<PIN11>
				<NAME>[PD6:ICP]</NAME>
				<TEXT/>
			</PIN11>
			<PIN12>
				<NAME>[PB0:AIN0]</NAME>
				<TEXT/>
			</PIN12>
			<PIN13>
				<NAME>[PB1:AIN1]</NAME>
				<TEXT/>
			</PIN13>
			<PIN14>
				<NAME>[PB2:OC0A]</NAME>
				<TEXT/>
			</PIN14>
			<PIN15>
				<NAME>[PB3:OC1A]</NAME>
				<TEXT/>
			</PIN15>
			<PIN16>
				<NAME>[PB4:OC1B]</NAME>
				<TEXT/>
			</PIN16>
			<PIN17>
				<NAME>[PB5:MOSI:DI]</NAME>
				<TEXT/>
			</PIN17>
			<PIN18>
				<NAME>[PB6:MISO:DO]</NAME>
				<TEXT/>
			</PIN18>
			<PIN19>
				<NAME>[PB7:SCK:SCL]</NAME>
				<TEXT/>
			</PIN19>
			<PIN20>
				<NAME>VCC</NAME>
				<TEXT/>
			</PIN20>
		</DIP>
		<SOIC>
			<NMB_PIN>20</NMB_PIN>
			<PIN1>
				<NAME>['RESET]</NAME>
				<TEXT/>
			</PIN1>
			<PIN2>
				<NAME>[PD0:RXD]</NAME>
				<TEXT/>
			</PIN2>
			<PIN3>
				<NAME>[PD1:TXD]</NAME>
				<TEXT/>
			</PIN3>
			<PIN4>
				<NAME>[XTAL2:PA1]</NAME>
				<TEXT/>
			</PIN4>
			<PIN5>
				<NAME>[XTAL1:PA0]</NAME>
				<TEXT/>
			</PIN5>
			<PIN6>
				<NAME>[PD2:INT0:XCK:CKOUT]</NAME>
				<TEXT/>
			</PIN6>
			<PIN7>
				<NAME>[PD3:INT1]</NAME>
				<TEXT/>
			</PIN7>
			<PIN8>
				<NAME>[PD4:T0]</NAME>
				<TEXT/>
			</PIN8>
			<PIN9>
				<NAME>[PD5:T1:OC0B]</NAME>
				<TEXT/>
			</PIN9>
			<PIN10>
				<NAME>[GND]</NAME>
				<TEXT/>
			</PIN10>
			<PIN11>
				<NAME>[PD6:ICP]</NAME>
				<TEXT/>
			</PIN11>
			<PIN12>
				<NAME>[PB0:AIN0]</NAME>
				<TEXT/>
			</PIN12>
			<PIN13>
				<NAME>[PB1:AIN1]</NAME>
				<TEXT/>
			</PIN13>
			<PIN14>
				<NAME>[PB2:OC0A]</NAME>
				<TEXT/>
			</PIN14>
			<PIN15>
				<NAME>[PB3:OC1A]</NAME>
				<TEXT/>
			</PIN15>
			<PIN16>
				<NAME>[PB4:OC1B]</NAME>
				<TEXT/>
			</PIN16>
			<PIN17>
				<NAME>[PB5:MOSI:DI]</NAME>
				<TEXT/>
			</PIN17>
			<PIN18>
				<NAME>[PB6:MISO:DO]</NAME>
				<TEXT/>
			</PIN18>
			<PIN19>
				<NAME>[PB7:SCK:SCL]</NAME>
				<TEXT/>
			</PIN19>
			<PIN20>
				<NAME>VCC</NAME>
				<TEXT/>
			</PIN20>
		</SOIC>
	</PACKAGE>
	<MEMORY>
		<ID>AVRSimMemory8bit.SimMemory8bit</ID>
		<PROG_FLASH>2048</PROG_FLASH>
		<EEPROM>128</EEPROM>
		<INT_SRAM>
			<SIZE>128</SIZE>
			<START_ADDR>$60</START_ADDR>
		</INT_SRAM>
		<EXT_SRAM>
			<SIZE>0</SIZE>
			<START_ADDR>NA</START_ADDR>
		</EXT_SRAM>
		<IO_MEMORY>
			<IO_START_ADDR>$00</IO_START_ADDR>
			<IO_STOP_ADDR>$3F</IO_STOP_ADDR>
			<EXT_IO_START_ADDR>NA</EXT_IO_START_ADDR>
			<EXT_IO_STOP_ADDR>NA</EXT_IO_STOP_ADDR>
			<MEM_START_ADDR>$20</MEM_START_ADDR>
			<MEM_STOP_ADDR>$5F</MEM_STOP_ADDR>
			<SREG>
				<IO_ADDR>$3F</IO_ADDR>
				<MEM_ADDR>$5F</MEM_ADDR>
				<C_MASK>0x01</C_MASK><Z_MASK>0x02</Z_MASK><N_MASK>0x04</N_MASK><V_MASK>0x08</V_MASK><S_MASK>0x10</S_MASK><H_MASK>0x20</H_MASK><T_MASK>0x40</T_MASK><I_MASK>0x80</I_MASK></SREG>
			<SPL>
				<IO_ADDR>$3D</IO_ADDR>
				<MEM_ADDR>$5D</MEM_ADDR>
				<SP0_MASK>0x01</SP0_MASK><SP1_MASK>0x02</SP1_MASK><SP2_MASK>0x04</SP2_MASK><SP3_MASK>0x08</SP3_MASK><SP4_MASK>0x10</SP4_MASK><SP5_MASK>0x20</SP5_MASK><SP6_MASK>0x40</SP6_MASK><SP7_MASK>0x80</SP7_MASK></SPL>
			<OCR0B>
				<IO_ADDR>$3C</IO_ADDR>
				<MEM_ADDR>$5C</MEM_ADDR>
				<OCR0_0_MASK>0x01</OCR0_0_MASK><OCR0_1_MASK>0x02</OCR0_1_MASK><OCR0_2_MASK>0x04</OCR0_2_MASK><OCR0_3_MASK>0x08</OCR0_3_MASK><OCR0_4_MASK>0x10</OCR0_4_MASK><OCR0_5_MASK>0x20</OCR0_5_MASK><OCR0_6_MASK>0x40</OCR0_6_MASK><OCR0_7_MASK>0x80</OCR0_7_MASK></OCR0B>
			<GIMSK>
				<IO_ADDR>$3B</IO_ADDR>
				<MEM_ADDR>$5B</MEM_ADDR>
				<PCIE_MASK>0x20</PCIE_MASK><INT0_MASK>0x40</INT0_MASK><INT1_MASK>0x80</INT1_MASK></GIMSK>
			<EIFR>
				<IO_ADDR>$3A</IO_ADDR>
				<MEM_ADDR>$5A</MEM_ADDR>
				<PCIF_MASK>0x20</PCIF_MASK><INTF0_MASK>0x40</INTF0_MASK><INTF1_MASK>0x80</INTF1_MASK></EIFR>
			<TIMSK>
				<IO_ADDR>$39</IO_ADDR>
				<MEM_ADDR>$59</MEM_ADDR>
				<OCIE0A_MASK>0x01</OCIE0A_MASK><TOIE0_MASK>0x02</TOIE0_MASK><OCIE0B_MASK>0x04</OCIE0B_MASK><ICIE1_MASK>0x08</ICIE1_MASK><OCIE1B_MASK>0x20</OCIE1B_MASK><OCIE1A_MASK>0x40</OCIE1A_MASK><TOIE1_MASK>0x80</TOIE1_MASK></TIMSK>
			<TIFR>
				<IO_ADDR>$38</IO_ADDR>
				<MEM_ADDR>$58</MEM_ADDR>
				<OCF0A_MASK>0x01</OCF0A_MASK><TOV0_MASK>0x02</TOV0_MASK><OCF0B_MASK>0x04</OCF0B_MASK><ICF1_MASK>0x08</ICF1_MASK><OCF1B_MASK>0x20</OCF1B_MASK><OCF1A_MASK>0x40</OCF1A_MASK><TOV1_MASK>0x80</TOV1_MASK></TIFR>
			<SPMCSR>
				<IO_ADDR>$37</IO_ADDR>
				<MEM_ADDR>$57</MEM_ADDR>
				<SPMEN_MASK>0x01</SPMEN_MASK><PGERS_MASK>0x02</PGERS_MASK><PGWRT_MASK>0x04</PGWRT_MASK><RFLB_MASK>0x08</RFLB_MASK><CTPB_MASK>0x10</CTPB_MASK></SPMCSR>
			<OCR0A>
				<IO_ADDR>$36</IO_ADDR>
				<MEM_ADDR>$56</MEM_ADDR>
				<OCR0_0_MASK>0x01</OCR0_0_MASK><OCR0_1_MASK>0x02</OCR0_1_MASK><OCR0_2_MASK>0x04</OCR0_2_MASK><OCR0_3_MASK>0x08</OCR0_3_MASK><OCR0_4_MASK>0x10</OCR0_4_MASK><OCR0_5_MASK>0x20</OCR0_5_MASK><OCR0_6_MASK>0x40</OCR0_6_MASK><OCR0_7_MASK>0x80</OCR0_7_MASK></OCR0A>
			<MCUCR>
				<IO_ADDR>$35</IO_ADDR>
				<MEM_ADDR>$55</MEM_ADDR>
				<ISC00_MASK>0x01</ISC00_MASK><ISC01_MASK>0x02</ISC01_MASK><ISC10_MASK>0x04</ISC10_MASK><ISC11_MASK>0x08</ISC11_MASK><SM0_MASK>0x10</SM0_MASK><SE_MASK>0x20</SE_MASK><SM1_MASK>0x40</SM1_MASK><PUD_MASK>0x80</PUD_MASK></MCUCR>
			<MCUSR>
				<IO_ADDR>$34</IO_ADDR>
				<MEM_ADDR>$54</MEM_ADDR>
				<PORF_MASK>0x01</PORF_MASK><EXTRF_MASK>0x02</EXTRF_MASK><BORF_MASK>0x04</BORF_MASK><WDRF_MASK>0x08</WDRF_MASK></MCUSR>
			<TCCR0B>
				<IO_ADDR>$33</IO_ADDR>
				<MEM_ADDR>$53</MEM_ADDR>
				<CS00_MASK>0x01</CS00_MASK><CS01_MASK>0x02</CS01_MASK><CS02_MASK>0x04</CS02_MASK><WGM02_MASK>0x08</WGM02_MASK><FOC0B_MASK>0x40</FOC0B_MASK><FOC0A_MASK>0x80</FOC0A_MASK></TCCR0B>
			<TCNT0>
				<IO_ADDR>$32</IO_ADDR>
				<MEM_ADDR>$52</MEM_ADDR>
				<TCNT0_0_MASK>0x01</TCNT0_0_MASK><TCNT0_1_MASK>0x02</TCNT0_1_MASK><TCNT0_2_MASK>0x04</TCNT0_2_MASK><TCNT0_3_MASK>0x08</TCNT0_3_MASK><TCNT0_4_MASK>0x10</TCNT0_4_MASK><TCNT0_5_MASK>0x20</TCNT0_5_MASK><TCNT0_6_MASK>0x40</TCNT0_6_MASK><TCNT0_7_MASK>0x80</TCNT0_7_MASK></TCNT0>
			<OSCCAL>
				<IO_ADDR>$31</IO_ADDR>
				<MEM_ADDR>$51</MEM_ADDR>
				<CAL0_MASK>0x01</CAL0_MASK><CAL1_MASK>0x02</CAL1_MASK><CAL2_MASK>0x04</CAL2_MASK><CAL3_MASK>0x08</CAL3_MASK><CAL4_MASK>0x10</CAL4_MASK><CAL5_MASK>0x20</CAL5_MASK><CAL6_MASK>0x40</CAL6_MASK></OSCCAL>
			<TCCR0A>
				<IO_ADDR>$30</IO_ADDR>
				<MEM_ADDR>$50</MEM_ADDR>
				<WGM00_MASK>0x01</WGM00_MASK><WGM01_MASK>0x02</WGM01_MASK><COM0B0_MASK>0x10</COM0B0_MASK><COM0B1_MASK>0x20</COM0B1_MASK><COM0A0_MASK>0x40</COM0A0_MASK><COM0A1_MASK>0x80</COM0A1_MASK></TCCR0A>
			<TCCR1A>
				<IO_ADDR>$2F</IO_ADDR>
				<MEM_ADDR>$4F</MEM_ADDR>
				<PWM10_MASK>0x01</PWM10_MASK><PWM11_MASK>0x02</PWM11_MASK><COM1B0_MASK>0x10</COM1B0_MASK><COM1B1_MASK>0x20</COM1B1_MASK><COM1A0_MASK>0x40</COM1A0_MASK><COM1A1_MASK>0x80</COM1A1_MASK></TCCR1A>
			<TCCR1B>
				<IO_ADDR>$2E</IO_ADDR>
				<MEM_ADDR>$4E</MEM_ADDR>
				<CS10_MASK>0x01</CS10_MASK><CS11_MASK>0x02</CS11_MASK><CS12_MASK>0x04</CS12_MASK><WGM12_MASK>0x08</WGM12_MASK><WGM13_MASK>0x10</WGM13_MASK><ICES1_MASK>0x40</ICES1_MASK><ICNC1_MASK>0x80</ICNC1_MASK></TCCR1B>
			<TCNT1H>
				<IO_ADDR>$2D</IO_ADDR>
				<MEM_ADDR>$4D</MEM_ADDR>
				<TCNT1H0_MASK>0x01</TCNT1H0_MASK><TCNT1H1_MASK>0x02</TCNT1H1_MASK><TCNT1H2_MASK>0x04</TCNT1H2_MASK><TCNT1H3_MASK>0x08</TCNT1H3_MASK><TCNT1H4_MASK>0x10</TCNT1H4_MASK><TCNT1H5_MASK>0x20</TCNT1H5_MASK><TCNT1H6_MASK>0x40</TCNT1H6_MASK><TCNT1H7_MASK>0x80</TCNT1H7_MASK></TCNT1H>
			<TCNT1L>
				<IO_ADDR>$2C</IO_ADDR>
				<MEM_ADDR>$4C</MEM_ADDR>
				<TCNT1L0_MASK>0x01</TCNT1L0_MASK><TCNT1L1_MASK>0x02</TCNT1L1_MASK><TCNT1L2_MASK>0x04</TCNT1L2_MASK><TCNT1L3_MASK>0x08</TCNT1L3_MASK><TCNT1L4_MASK>0x10</TCNT1L4_MASK><TCNT1L5_MASK>0x20</TCNT1L5_MASK><TCNT1L6_MASK>0x40</TCNT1L6_MASK><TCNT1L7_MASK>0x80</TCNT1L7_MASK></TCNT1L>
			<OCR1AH>
				<IO_ADDR>$2B</IO_ADDR>
				<MEM_ADDR>$4B</MEM_ADDR>
				<OCR1AH0_MASK>0x01</OCR1AH0_MASK><OCR1AH1_MASK>0x02</OCR1AH1_MASK><OCR1AH2_MASK>0x04</OCR1AH2_MASK><OCR1AH3_MASK>0x08</OCR1AH3_MASK><OCR1AH4_MASK>0x10</OCR1AH4_MASK><OCR1AH5_MASK>0x20</OCR1AH5_MASK><OCR1AH6_MASK>0x40</OCR1AH6_MASK><OCR1AH7_MASK>0x80</OCR1AH7_MASK></OCR1AH>
			<OCR1AL>
				<IO_ADDR>$2A</IO_ADDR>
				<MEM_ADDR>$4A</MEM_ADDR>
				<OCR1AL0_MASK>0x01</OCR1AL0_MASK><OCR1AL1_MASK>0x02</OCR1AL1_MASK><OCR1AL2_MASK>0x04</OCR1AL2_MASK><OCR1AL3_MASK>0x08</OCR1AL3_MASK><OCR1AL4_MASK>0x10</OCR1AL4_MASK><OCR1AL5_MASK>0x20</OCR1AL5_MASK><OCR1AL6_MASK>0x40</OCR1AL6_MASK><OCR1AL7_MASK>0x80</OCR1AL7_MASK></OCR1AL>
			<OCR1BH>
				<IO_ADDR>$29</IO_ADDR>
				<MEM_ADDR>$49</MEM_ADDR>
				<OCR1AH0_MASK>0x01</OCR1AH0_MASK><OCR1AH1_MASK>0x02</OCR1AH1_MASK><OCR1AH2_MASK>0x04</OCR1AH2_MASK><OCR1AH3_MASK>0x08</OCR1AH3_MASK><OCR1AH4_MASK>0x10</OCR1AH4_MASK><OCR1AH5_MASK>0x20</OCR1AH5_MASK><OCR1AH6_MASK>0x40</OCR1AH6_MASK><OCR1AH7_MASK>0x80</OCR1AH7_MASK></OCR1BH>
			<OCR1BL>
				<IO_ADDR>$28</IO_ADDR>
				<MEM_ADDR>$48</MEM_ADDR>
				<OCR1AL0_MASK>0x01</OCR1AL0_MASK><OCR1AL1_MASK>0x02</OCR1AL1_MASK><OCR1AL2_MASK>0x04</OCR1AL2_MASK><OCR1AL3_MASK>0x08</OCR1AL3_MASK><OCR1AL4_MASK>0x10</OCR1AL4_MASK><OCR1AL5_MASK>0x20</OCR1AL5_MASK><OCR1AL6_MASK>0x40</OCR1AL6_MASK><OCR1AL7_MASK>0x80</OCR1AL7_MASK></OCR1BL>
			<ICR1H>
				<IO_ADDR>$25</IO_ADDR>
				<MEM_ADDR>$45</MEM_ADDR>
				<ICR1H0_MASK>0x01</ICR1H0_MASK><ICR1H1_MASK>0x02</ICR1H1_MASK><ICR1H2_MASK>0x04</ICR1H2_MASK><ICR1H3_MASK>0x08</ICR1H3_MASK><ICR1H4_MASK>0x10</ICR1H4_MASK><ICR1H5_MASK>0x20</ICR1H5_MASK><ICR1H6_MASK>0x40</ICR1H6_MASK><ICR1H7_MASK>0x80</ICR1H7_MASK></ICR1H>
			<ICR1L>
				<IO_ADDR>$24</IO_ADDR>
				<MEM_ADDR>$44</MEM_ADDR>
				<ICR1L0_MASK>0x01</ICR1L0_MASK><ICR1L1_MASK>0x02</ICR1L1_MASK><ICR1L2_MASK>0x04</ICR1L2_MASK><ICR1L3_MASK>0x08</ICR1L3_MASK><ICR1L4_MASK>0x10</ICR1L4_MASK><ICR1L5_MASK>0x20</ICR1L5_MASK><ICR1L6_MASK>0x40</ICR1L6_MASK><ICR1L7_MASK>0x80</ICR1L7_MASK></ICR1L>
			<GTCCR>
				<IO_ADDR>$23</IO_ADDR>
				<MEM_ADDR>$43</MEM_ADDR>
				<PSR10_MASK>0x01</PSR10_MASK></GTCCR>
			<TCCR1C>
				<IO_ADDR>$22</IO_ADDR>
				<MEM_ADDR>$42</MEM_ADDR>
				<FOC1B_MASK>0x40</FOC1B_MASK><FOC1A_MASK>0x80</FOC1A_MASK></TCCR1C>
			<WDTCR>
				<IO_ADDR>$21</IO_ADDR>
				<MEM_ADDR>$41</MEM_ADDR>
				<WDP0_MASK>0x01</WDP0_MASK><WDP1_MASK>0x02</WDP1_MASK><WDP2_MASK>0x04</WDP2_MASK><WDE_MASK>0x08</WDE_MASK><WDCE_MASK>0x10</WDCE_MASK><WDP3_MASK>0x20</WDP3_MASK><WDTIE_MASK>0x40</WDTIE_MASK><WDTIF_MASK>0x80</WDTIF_MASK></WDTCR>
			<PCMSK>
				<IO_ADDR>$20</IO_ADDR>
				<MEM_ADDR>$40</MEM_ADDR>
				<PCINT0_MASK>0x01</PCINT0_MASK><PCINT1_MASK>0x02</PCINT1_MASK><PCINT2_MASK>0x04</PCINT2_MASK><PCINT3_MASK>0x08</PCINT3_MASK><PCINT4_MASK>0x10</PCINT4_MASK><PCINT5_MASK>0x20</PCINT5_MASK><PCINT6_MASK>0x40</PCINT6_MASK><PCINT7_MASK>0x80</PCINT7_MASK></PCMSK>
			<EEAR>
				<IO_ADDR>$1E</IO_ADDR>
				<MEM_ADDR>$3E</MEM_ADDR>
				<EEAR0_MASK>0x01</EEAR0_MASK><EEAR1_MASK>0x02</EEAR1_MASK><EEAR2_MASK>0x04</EEAR2_MASK><EEAR3_MASK>0x08</EEAR3_MASK><EEAR4_MASK>0x10</EEAR4_MASK><EEAR5_MASK>0x20</EEAR5_MASK><EEAR6_MASK>0x40</EEAR6_MASK></EEAR>
			<EEDR>
				<IO_ADDR>$1D</IO_ADDR>
				<MEM_ADDR>$3D</MEM_ADDR>
				<EEDR0_MASK>0x01</EEDR0_MASK><EEDR1_MASK>0x02</EEDR1_MASK><EEDR2_MASK>0x04</EEDR2_MASK><EEDR3_MASK>0x08</EEDR3_MASK><EEDR4_MASK>0x10</EEDR4_MASK><EEDR5_MASK>0x20</EEDR5_MASK><EEDR6_MASK>0x40</EEDR6_MASK><EEDR7_MASK>0x80</EEDR7_MASK></EEDR>
			<EECR>
				<IO_ADDR>$1C</IO_ADDR>
				<MEM_ADDR>$3C</MEM_ADDR>
				<EERE_MASK>0x01</EERE_MASK><EEWE_MASK>0x02</EEWE_MASK><EEMWE_MASK>0x04</EEMWE_MASK><EERIE_MASK>0x08</EERIE_MASK><EEPM0_MASK>0x10</EEPM0_MASK><EEPM1_MASK>0x20</EEPM1_MASK></EECR>
			<PORTA>
				<IO_ADDR>$1B</IO_ADDR>
				<MEM_ADDR>$3B</MEM_ADDR>
				<PORTA0_MASK>0x01</PORTA0_MASK><PORTA1_MASK>0x02</PORTA1_MASK><PORTA2_MASK>0x04</PORTA2_MASK></PORTA>
			<DDRA>
				<IO_ADDR>$1A</IO_ADDR>
				<MEM_ADDR>$3A</MEM_ADDR>
				<DDRA0_MASK>0x01</DDRA0_MASK><DDRA1_MASK>0x02</DDRA1_MASK><DDRA2_MASK>0x04</DDRA2_MASK></DDRA>
			<PINA>
				<IO_ADDR>$19</IO_ADDR>
				<MEM_ADDR>$39</MEM_ADDR>
				<PINA0_MASK>0x01</PINA0_MASK><PINA1_MASK>0x02</PINA1_MASK><PINA2_MASK>0x04</PINA2_MASK></PINA>
			<PORTB>
				<IO_ADDR>$18</IO_ADDR>
				<MEM_ADDR>$38</MEM_ADDR>
				<MASK>$ff</MASK>
				<PORTB0_MASK>0x01</PORTB0_MASK><PORTB1_MASK>0x02</PORTB1_MASK><PORTB2_MASK>0x04</PORTB2_MASK><PORTB3_MASK>0x08</PORTB3_MASK><PORTB4_MASK>0x10</PORTB4_MASK><PORTB5_MASK>0x20</PORTB5_MASK><PORTB6_MASK>0x40</PORTB6_MASK><PORTB7_MASK>0x80</PORTB7_MASK></PORTB>
			<DDRB>
				<IO_ADDR>$17</IO_ADDR>
				<MEM_ADDR>$37</MEM_ADDR>
				<DDRB0_MASK>0x01</DDRB0_MASK><DDRB1_MASK>0x02</DDRB1_MASK><DDRB2_MASK>0x04</DDRB2_MASK><DDRB3_MASK>0x08</DDRB3_MASK><DDRB4_MASK>0x10</DDRB4_MASK><DDRB5_MASK>0x20</DDRB5_MASK><DDRB6_MASK>0x40</DDRB6_MASK><DDRB7_MASK>0x80</DDRB7_MASK></DDRB>
			<PINB>
				<IO_ADDR>$16</IO_ADDR>
				<MEM_ADDR>$36</MEM_ADDR>
				<PINB0_MASK>0x01</PINB0_MASK><PINB1_MASK>0x02</PINB1_MASK><PINB2_MASK>0x04</PINB2_MASK><PINB3_MASK>0x08</PINB3_MASK><PINB4_MASK>0x10</PINB4_MASK><PINB5_MASK>0x20</PINB5_MASK><PINB6_MASK>0x40</PINB6_MASK><PINB7_MASK>0x80</PINB7_MASK></PINB>
			<GPIOR2>
				<IO_ADDR>$15</IO_ADDR>
				<MEM_ADDR>$35</MEM_ADDR>
				<GPIOR20_MASK>0x01</GPIOR20_MASK><GPIOR21_MASK>0x02</GPIOR21_MASK><GPIOR22_MASK>0x04</GPIOR22_MASK><GPIOR23_MASK>0x08</GPIOR23_MASK><GPIOR24_MASK>0x10</GPIOR24_MASK><GPIOR25_MASK>0x20</GPIOR25_MASK><GPIOR26_MASK>0x40</GPIOR26_MASK><GPIOR27_MASK>0x80</GPIOR27_MASK></GPIOR2>
			<GPIOR1>
				<IO_ADDR>$14</IO_ADDR>
				<MEM_ADDR>$34</MEM_ADDR>
				<GPIOR10_MASK>0x01</GPIOR10_MASK><GPIOR11_MASK>0x02</GPIOR11_MASK><GPIOR12_MASK>0x04</GPIOR12_MASK><GPIOR13_MASK>0x08</GPIOR13_MASK><GPIOR14_MASK>0x10</GPIOR14_MASK><GPIOR15_MASK>0x20</GPIOR15_MASK><GPIOR16_MASK>0x40</GPIOR16_MASK><GPIOR17_MASK>0x80</GPIOR17_MASK></GPIOR1>
			<GPIOR0>
				<IO_ADDR>$13</IO_ADDR>
				<MEM_ADDR>$33</MEM_ADDR>
				<GPIOR00_MASK>0x01</GPIOR00_MASK><GPIOR01_MASK>0x02</GPIOR01_MASK><GPIOR02_MASK>0x04</GPIOR02_MASK><GPIOR03_MASK>0x08</GPIOR03_MASK><GPIOR04_MASK>0x10</GPIOR04_MASK><GPIOR05_MASK>0x20</GPIOR05_MASK><GPIOR06_MASK>0x40</GPIOR06_MASK><GPIOR07_MASK>0x80</GPIOR07_MASK></GPIOR0>
			<PORTD>
				<IO_ADDR>$12</IO_ADDR>
				<MEM_ADDR>$32</MEM_ADDR>
				<MASK>$7f</MASK>
				<PORTD0_MASK>0x01</PORTD0_MASK><PORTD1_MASK>0x02</PORTD1_MASK><PORTD2_MASK>0x04</PORTD2_MASK><PORTD3_MASK>0x08</PORTD3_MASK><PORTD4_MASK>0x10</PORTD4_MASK><PORTD5_MASK>0x20</PORTD5_MASK><PORTD6_MASK>0x40</PORTD6_MASK></PORTD>
			<DDRD>
				<IO_ADDR>$11</IO_ADDR>
				<MEM_ADDR>$31</MEM_ADDR>
				<DDRD0_MASK>0x01</DDRD0_MASK><DDRD1_MASK>0x02</DDRD1_MASK><DDRD2_MASK>0x04</DDRD2_MASK><DDRD3_MASK>0x08</DDRD3_MASK><DDRD4_MASK>0x10</DDRD4_MASK><DDRD5_MASK>0x20</DDRD5_MASK><DDRD6_MASK>0x40</DDRD6_MASK></DDRD>
			<PIND>
				<IO_ADDR>$10</IO_ADDR>
				<MEM_ADDR>$30</MEM_ADDR>
				<PIND0_MASK>0x01</PIND0_MASK><PIND1_MASK>0x02</PIND1_MASK><PIND2_MASK>0x04</PIND2_MASK><PIND3_MASK>0x08</PIND3_MASK><PIND4_MASK>0x10</PIND4_MASK><PIND5_MASK>0x20</PIND5_MASK><PIND6_MASK>0x40</PIND6_MASK></PIND>
			<USIDR>
				<IO_ADDR>$0F</IO_ADDR>
				<MEM_ADDR>$2F</MEM_ADDR>
				<USIDR0_MASK>0x01</USIDR0_MASK><USIDR1_MASK>0x02</USIDR1_MASK><USIDR2_MASK>0x04</USIDR2_MASK><USIDR3_MASK>0x08</USIDR3_MASK><USIDR4_MASK>0x10</USIDR4_MASK><USIDR5_MASK>0x20</USIDR5_MASK><USIDR6_MASK>0x40</USIDR6_MASK><USIDR7_MASK>0x80</USIDR7_MASK></USIDR>
			<USISR>
				<IO_ADDR>$0E</IO_ADDR>
				<MEM_ADDR>$2E</MEM_ADDR>
				<USICNT0_MASK>0x01</USICNT0_MASK><USICNT1_MASK>0x02</USICNT1_MASK><USICNT2_MASK>0x04</USICNT2_MASK><USICNT3_MASK>0x08</USICNT3_MASK><USIDC_MASK>0x10</USIDC_MASK><USIPF_MASK>0x20</USIPF_MASK><USIOIF_MASK>0x40</USIOIF_MASK><USISIF_MASK>0x80</USISIF_MASK></USISR>
			<USICR>
				<IO_ADDR>$0D</IO_ADDR>
				<MEM_ADDR>$2D</MEM_ADDR>
				<USITC_MASK>0x01</USITC_MASK><USICLK_MASK>0x02</USICLK_MASK><USICS0_MASK>0x04</USICS0_MASK><USICS1_MASK>0x08</USICS1_MASK><USIWM0_MASK>0x10</USIWM0_MASK><USIWM1_MASK>0x20</USIWM1_MASK><USIOIE_MASK>0x40</USIOIE_MASK><USISIE_MASK>0x80</USISIE_MASK></USICR>
			<UDR>
				<IO_ADDR>$0C</IO_ADDR>
				<MEM_ADDR>$2C</MEM_ADDR>
				<UDR0_MASK>0x01</UDR0_MASK><UDR1_MASK>0x02</UDR1_MASK><UDR2_MASK>0x04</UDR2_MASK><UDR3_MASK>0x08</UDR3_MASK><UDR4_MASK>0x10</UDR4_MASK><UDR5_MASK>0x20</UDR5_MASK><UDR6_MASK>0x40</UDR6_MASK><UDR7_MASK>0x80</UDR7_MASK></UDR>
			<UCSRA>
				<IO_ADDR>$0B</IO_ADDR>
				<MEM_ADDR>$02B</MEM_ADDR>
				<MPCM_MASK>0x01</MPCM_MASK><U2X_MASK>0x02</U2X_MASK><UPE_MASK>0x04</UPE_MASK><DOR_MASK>0x08</DOR_MASK><FE_MASK>0x10</FE_MASK><UDRE_MASK>0x20</UDRE_MASK><TXC_MASK>0x40</TXC_MASK><RXC_MASK>0x80</RXC_MASK></UCSRA>
			<UCSRB>
				<IO_ADDR>$0A</IO_ADDR>
				<MEM_ADDR>$02A</MEM_ADDR>
				<TXB8_MASK>0x01</TXB8_MASK><RXB8_MASK>0x02</RXB8_MASK><UCSZ2_MASK>0x04</UCSZ2_MASK><TXEN_MASK>0x08</TXEN_MASK><RXEN_MASK>0x10</RXEN_MASK><UDRIE_MASK>0x20</UDRIE_MASK><TXCIE_MASK>0x40</TXCIE_MASK><RXCIE_MASK>0x80</RXCIE_MASK></UCSRB>
			<UBRRL>
				<IO_ADDR>$09</IO_ADDR>
				<MEM_ADDR>$29</MEM_ADDR>
				<UBRR0_MASK>0x01</UBRR0_MASK><UBRR1_MASK>0x02</UBRR1_MASK><UBRR2_MASK>0x04</UBRR2_MASK><UBRR3_MASK>0x08</UBRR3_MASK><UBRR4_MASK>0x10</UBRR4_MASK><UBRR5_MASK>0x20</UBRR5_MASK><UBRR6_MASK>0x40</UBRR6_MASK><UBRR7_MASK>0x80</UBRR7_MASK></UBRRL>
			<ACSR>
				<IO_ADDR>$08</IO_ADDR>
				<MEM_ADDR>$28</MEM_ADDR>
				<ACIS0_MASK>0x01</ACIS0_MASK><ACIS1_MASK>0x02</ACIS1_MASK><ACIC_MASK>0x04</ACIC_MASK><ACIE_MASK>0x08</ACIE_MASK><ACI_MASK>0x10</ACI_MASK><ACO_MASK>0x20</ACO_MASK><ACBG_MASK>0x40</ACBG_MASK><ACD_MASK>0x80</ACD_MASK></ACSR>
			<UCSRC>
				<IO_ADDR>$03</IO_ADDR>
				<MEM_ADDR>$23</MEM_ADDR>
				<UCPOL_MASK>0x01</UCPOL_MASK><UCSZ0_MASK>0x02</UCSZ0_MASK><UCSZ1_MASK>0x04</UCSZ1_MASK><USBS_MASK>0x08</USBS_MASK><UPM0_MASK>0x10</UPM0_MASK><UPM1_MASK>0x20</UPM1_MASK><UMSEL_MASK>0x40</UMSEL_MASK></UCSRC>
			<UBRRH>
				<IO_ADDR>$02</IO_ADDR>
				<MEM_ADDR>$22</MEM_ADDR>
				<UBRR8_MASK>0x01</UBRR8_MASK><UBRR9_MASK>0x02</UBRR9_MASK><UBRR10_MASK>0x04</UBRR10_MASK><UBRR11_MASK>0x08</UBRR11_MASK></UBRRH>
			<DIDR>
				<IO_ADDR>$01</IO_ADDR>
				<MEM_ADDR>$21</MEM_ADDR>
				<AIN0D_MASK>0x01</AIN0D_MASK><AIN1D_MASK>0x02</AIN1D_MASK></DIDR>
		</IO_MEMORY>
	</MEMORY>
	<IO_MODULE><MODULE_LIST>[PORTB:TIMER_COUNTER_0:TIMER_COUNTER_1:WATCHDOG:EXTERNAL_INTERRUPT:USART:ANALOG_COMPARATOR:PORTD:EEPROM:PORTA:CPU:USI]</MODULE_LIST><PORTB>
			<LIST>[PORTB:DDRB:PINB]</LIST>
			<LINK/>
			<ICON>io_port.bmp</ICON>
			<ID>AVRSimIOPort.SimIOPort</ID>
			<TEXT/>
			<PORTB>
				<NAME>PORTB</NAME>
				<DESCRIPTION>Port B Data Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$18</IO_ADDR>
				<MEM_ADDR>$38</MEM_ADDR>
				<ICON>io_port.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>PORTB7</NAME>
					<DESCRIPTION>Port B Data Register bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>PORTB6</NAME>
					<DESCRIPTION>Port B Data Register bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>PORTB5</NAME>
					<DESCRIPTION>Port B Data Register bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>PORTB4</NAME>
					<DESCRIPTION>Port B Data Register bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>PORTB3</NAME>
					<DESCRIPTION>Port B Data Register bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>PORTB2</NAME>
					<DESCRIPTION>Port B Data Register bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>PORTB1</NAME>
					<DESCRIPTION>Port B Data Register bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>PORTB0</NAME>
					<DESCRIPTION>Port B Data Register bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</PORTB>
			<DDRB>
				<NAME>DDRB</NAME>
				<DESCRIPTION>Port B Data Direction Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$17</IO_ADDR>
				<MEM_ADDR>$37</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>DDRB7</NAME>
					<DESCRIPTION>Port B Data Direction Register bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>DDRB6</NAME>
					<DESCRIPTION>Port B Data Direction Register bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>DDRB5</NAME>
					<DESCRIPTION>Port B Data Direction Register bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>DDRB4</NAME>
					<DESCRIPTION>Port B Data Direction Register bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>DDRB3</NAME>
					<DESCRIPTION>Port B Data Direction Register bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>DDRB2</NAME>
					<DESCRIPTION>Port B Data Direction Register bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>DDRB1</NAME>
					<DESCRIPTION>Port B Data Direction Register bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>DDRB0</NAME>
					<DESCRIPTION>Port B Data Direction Register bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</DDRB>
			<PINB>
				<NAME>PINB</NAME>
				<DESCRIPTION>Port B Input Pins</DESCRIPTION>
				<TEXT>The Port B Input Pins address - PINB - is not a register, and this address enables access to the physical value on each Port B pin. When reading PORTB, the Port B Data Latch is read, and when reading PINB, the logical values present on the pins are read.</TEXT>
				<IO_ADDR>$16</IO_ADDR>
				<MEM_ADDR>$36</MEM_ADDR>
				<ICON>io_port.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>PINB7</NAME>
					<DESCRIPTION>Port B Input Pins bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>PINB6</NAME>
					<DESCRIPTION>Port B Input Pins bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>PINB5</NAME>
					<DESCRIPTION>Port B Input Pins bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>PINB4</NAME>
					<DESCRIPTION>Port B Input Pins bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>PINB3</NAME>
					<DESCRIPTION>Port B Input Pins bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>PINB2</NAME>
					<DESCRIPTION>Port B Input Pins bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>PINB1</NAME>
					<DESCRIPTION>Port B Input Pins bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>PINB0</NAME>
					<DESCRIPTION>Port B Input Pins bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</PINB>
		</PORTB>
		<TIMER_COUNTER_0>
			<LIST>[TIMSK:TIFR:OCR0B:OCR0A:TCCR0A:TCNT0:TCCR0B]</LIST>
			<LINK/>
			<ICON>io_timer.bmp</ICON>
			<ID>At8pwm0_11</ID>
			<TEXT/>
			<TIMSK>
				<NAME>TIMSK</NAME>
				<DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$39</IO_ADDR>
				<MEM_ADDR>$59</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT2>
					<NAME>OCIE0B</NAME>
					<DESCRIPTION>Timer/Counter0 Output Compare Match B Interrupt Enable</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>TOIE0</NAME>
					<DESCRIPTION>Timer/Counter0 Overflow Interrupt Enable</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>OCIE0A</NAME>
					<DESCRIPTION>Timer/Counter0 Output Compare Match A Interrupt Enable</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</TIMSK>
			<TIFR>
				<NAME>TIFR</NAME>
				<DESCRIPTION>Timer/Counter Interrupt Flag register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$38</IO_ADDR>
				<MEM_ADDR>$58</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT2>
					<NAME>OCF0B</NAME>
					<DESCRIPTION>Timer/Counter0 Output Compare Flag 0B</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>TOV0</NAME>
					<DESCRIPTION>Timer/Counter0 Overflow Flag</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>OCF0A</NAME>
					<DESCRIPTION>Timer/Counter0 Output Compare Flag 0A</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</TIFR>
			<OCR0B>
				<NAME>OCR0B</NAME>
				<DESCRIPTION>Timer/Counter0 Output Compare Register</DESCRIPTION>
				<TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT0). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC0 pin.</TEXT>
				<IO_ADDR>$3C</IO_ADDR>
				<MEM_ADDR>$5C</MEM_ADDR>
				<ICON>io_timer.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>OCR0_7</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>OCR0_6</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>OCR0_5</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>OCR0_4</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>OCR0_3</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>OCR0_2</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>OCR0_1</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>OCR0_0</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</OCR0B>
			<OCR0A>
				<NAME>OCR0A</NAME>
				<DESCRIPTION>Timer/Counter0 Output Compare Register</DESCRIPTION>
				<TEXT>The Output Compare Register contains an 8-bit value that is continuously compared with the counter value (TCNT0). A match can be used to generate an output compare interrupt, or to generate a waveform output on the OC0 pin.</TEXT>
				<IO_ADDR>$36</IO_ADDR>
				<MEM_ADDR>$56</MEM_ADDR>
				<ICON>io_timer.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>OCR0_7</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>OCR0_6</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>OCR0_5</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>OCR0_4</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>OCR0_3</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>OCR0_2</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>OCR0_1</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>OCR0_0</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</OCR0A>
			<TCCR0A>
				<NAME>TCCR0A</NAME>
				<DESCRIPTION>Timer/Counter  Control Register A</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$30</IO_ADDR>
				<MEM_ADDR>$50</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>COM0A1</NAME>
					<DESCRIPTION>Compare Match Output A Mode</DESCRIPTION>
					<TEXT>Controls Output Compare Pin A behaviour. Please refer to datasheet.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>COM0A0</NAME>
					<DESCRIPTION>Compare Match Output A Mode</DESCRIPTION>
					<TEXT>Controls Output Compare Pin A behaviour. Please refer to datasheet.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>COM0B1</NAME>
					<DESCRIPTION>Compare Match Output B Mode</DESCRIPTION>
					<TEXT>Controls Output Compare Pin B behaviour. Please refer to datasheet.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>COM0B0</NAME>
					<DESCRIPTION>Compare Match Output B Mode</DESCRIPTION>
					<TEXT>Controls Output Compare Pin B behaviour. Please refer to datasheet.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT1>
					<NAME>WGM01</NAME>
					<DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
					<TEXT>Controls the Waveform Generation Mode, please refer to datasheet for further details.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>WGM00</NAME>
					<DESCRIPTION>Waveform Generation Mode</DESCRIPTION>
					<TEXT>Controls the Waveform Generation Mode, please refer to datasheet for further details.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</TCCR0A>
			<TCNT0>
				<NAME>TCNT0</NAME>
				<DESCRIPTION>Timer/Counter0</DESCRIPTION>
				<TEXT>The Timer/Counter Register gives direct access, both for read and write operations, to the Timer/Counter unit 8-bit counter. Writing to the TCNT0 register blocks (removes) the compare match on the following timer clock. Modifying the counter (TCNT0) while the counter is running, introduces a risk of missing a compare match between TCNT0 the OCR0 register.</TEXT>
				<IO_ADDR>$32</IO_ADDR>
				<MEM_ADDR>$52</MEM_ADDR>
				<ICON>io_timer.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>TCNT0_7</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>TCNT0_6</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>TCNT0_5</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>TCNT0_4</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>TCNT0_3</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>TCNT0_2</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>TCNT0_1</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>TCNT0_0</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</TCNT0>
			<TCCR0B>
				<NAME>TCCR0B</NAME>
				<DESCRIPTION>Timer/Counter Control Register B</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$33</IO_ADDR>
				<MEM_ADDR>$53</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>FOC0A</NAME>
					<DESCRIPTION>Force Output Compare B</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>FOC0B</NAME>
					<DESCRIPTION>Force Output Compare B</DESCRIPTION>
					<TEXT/>
					<ACCESS>W</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT3>
					<NAME>WGM02</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACESS>RW</ACESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>CS02</NAME>
					<DESCRIPTION>Clock Select</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>CS01</NAME>
					<DESCRIPTION>Clock Select</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>CS00</NAME>
					<DESCRIPTION>Clock Select</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</TCCR0B>
		</TIMER_COUNTER_0>
		<TIMER_COUNTER_1>
			<LIST>[TIMSK:TIFR:TCCR1A:TCCR1B:TCCR1C:TCNT1H:TCNT1L:OCR1AH:OCR1AL:OCR1BH:OCR1BL:ICR1H:ICR1L]</LIST>
			<LINK>[TCNT1H:TCNT1L];[OCR1AH:OCR1AL];[OCR1BH:OCR1BL];[ICR1H:ICR1L]</LINK>
			<ICON>io_timer.bmp</ICON>
			<ID>t16pwm1_13.xml</ID>
			<TEXT/>
			<TIMSK>
				<NAME>TIMSK</NAME>
				<DESCRIPTION>Timer/Counter Interrupt Mask Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$39</IO_ADDR>
				<MEM_ADDR>$59</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>TOIE1</NAME>
					<DESCRIPTION>Timer/Counter1 Overflow Interrupt Enable</DESCRIPTION>
					<TEXT>When the TOIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Overflow interrupt is enabled. The corresponding interrupt  is executed if an overflow in Timer/Counter1 occurs, i.e., when the TOV1 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>OCIE1A</NAME>
					<DESCRIPTION>Timer/Counter1 Output CompareA Match Interrupt Enable</DESCRIPTION>
					<TEXT>When the OCIE1A bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 CompareA Match interrupt is enabled. The corresponding interrupt (at vector $004) is executed if a CompareA match in Timer/Counter1 occurs, i.e., when the OCF1A bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>OCIE1B</NAME>
					<DESCRIPTION>Timer/Counter1 Output CompareB Match Interrupt Enable</DESCRIPTION>
					<TEXT>When the OCIE1B bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 CompareB Match interrupt is enabled. The corresponding interrupt  is executed if a CompareB match in Timer/Counter1 occurs, i.e., when the OCF1B bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT3>
					<NAME>ICIE1</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Interrupt Enable</DESCRIPTION>
					<TEXT>When the TICIE1 bit is set (one) and the I-bit in the Status Register is set (one), the Timer/Counter1 Input Capture Event Interrupt is enabled. The corresponding interrupt (at vector $003) is executed if a capture-triggering event occurs on pin  ICP, i.e., when the ICF1 bit is set in the Timer/Counter Interrupt Flag Register - TIFR.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
			</TIMSK>
			<TIFR>
				<NAME>TIFR</NAME>
				<DESCRIPTION>Timer/Counter Interrupt Flag register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$38</IO_ADDR>
				<MEM_ADDR>$58</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>TOV1</NAME>
					<DESCRIPTION>Timer/Counter1 Overflow Flag</DESCRIPTION>
					<TEXT>The TOV1 is set (one) when an overflow occurs in Timer/Counter1. TOV1 is cleared by hardware when executing the cor-responding interrupt handling vector. Alternatively, TOV1 is cleared by writing a logic one to the flag. When the I-bit in SREG, and TOIE1 (Timer/Counter1 Overflow Interrupt Enable), and TOV1 are set (one), the Timer/Counter1 Overflow Interrupt is executed. In PWM mode, this bit is set when Timer/Counter1 changes counting direction at $0000.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>OCF1A</NAME>
					<DESCRIPTION>Output Compare Flag 1A</DESCRIPTION>
					<TEXT>The OCF1A bit is set (one) when compare match occurs between the Timer/Counter1 and the data in OCR1A - Output Compare Register 1A. OCF1A is cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF1A is cleared by writing a logic one to the flag. When the I-bit in SREG, and OCIE1A (Timer/Counter1 Compare match InterruptA Enable), and the OCF1A are set (one), the Timer/Counter1 Compare A match Interrupt is executed. </TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>OCF1B</NAME>
					<DESCRIPTION>Output Compare Flag 1B</DESCRIPTION>
					<TEXT>The OCF1B bit is set (one) when compare match occurs between the Timer/Counter1 and the data in OCR1B - Output Compare Register 1B. OCF1B is cleared by hardware when executing the corresponding interrupt handling vector. Alterna-tively, OCF1B is cleared by writing a logic one to the flag. When the I-bit in SREG, and OCIE1A (Timer/Counter1 Compare match InterruptB Enable), and the OCF1B are set (one), the Timer/Counter1 Compare B match Interrupt is executed. </TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT3>
					<NAME>ICF1</NAME>
					<DESCRIPTION>Input Capture Flag 1</DESCRIPTION>
					<TEXT>The ICF1 bit is set (one) to flag an input capture event, indicating that the Timer/Counter1 value has been transferred to the input capture register - ICR1. ICF1 is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, ICF1 is cleared by writing a logic one to the flag. When the SREG I-bit, and TICIE1 (Timer/Counter1 Input Capture Interrupt Enable), and ICF1 are set (one), the Timer/Counter1 Capture Interrupt is executed. </TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
			</TIFR>
			<TCCR1A>
				<NAME>TCCR1A</NAME>
				<DESCRIPTION>Timer/Counter1 Control Register A</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$2F</IO_ADDR>
				<MEM_ADDR>$4F</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>COM1A1</NAME>
					<DESCRIPTION>Compare Output Mode 1A, bit 1</DESCRIPTION>
					<TEXT>The COM1A1 and COM1A0 control bits determine any output pin action following a compare match in Timer/Counter1. Any output pin actions affect pin OC1A - Output CompareA pin 1. This is an alternative function to an I/O port and the corresponding direction control bit must be set (one) to control the output pin. The control configuration is shown in the databook. </TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>COM1A0</NAME>
					<DESCRIPTION>Comparet Ouput Mode 1A, bit 0</DESCRIPTION>
					<TEXT>The COM1A1 and COM1A0 control bits determine any output pin action following a compare match in Timer/Counter1. Any output pin actions affect pin OC1A - Output CompareA pin 1. This is an alternative function to an I/O port and the corresponding direction control bit must be set (one) to control the output pin. The control configuration is shown in the databook. </TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>COM1B1</NAME>
					<DESCRIPTION>Compare Output Mode 1B, bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>COM1B0</NAME>
					<DESCRIPTION>Comparet Ouput Mode 1B, bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT1>
					<NAME>PWM11</NAME>
					<DESCRIPTION>Pulse Width Modulator Select Bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>PWM10</NAME>
					<DESCRIPTION>Pulse Width Modulator Select Bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</TCCR1A>
			<TCCR1B>
				<NAME>TCCR1B</NAME>
				<DESCRIPTION>Timer/Counter1 Control Register B</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$2E</IO_ADDR>
				<MEM_ADDR>$4E</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>ICNC1</NAME>
					<DESCRIPTION>Input Capture 1 Noise Canceler</DESCRIPTION>
					<TEXT>When the ICNC1 bit is cleared (zero), the input capture trigger noise canceler function is disabled. The input capture is triggered at the first rising/falling edge sampled on the ICP - input capture pin - as specified. When the ICNC1 bit is set (one), four successive samples are measures on the ICP - input capture pin, and all samples must be high/low according to the input capture trigger specification in the ICES1 bit. The actual sampling frequency is XTAL clock frequency.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>ICES1</NAME>
					<DESCRIPTION>Input Capture 1 Edge Select</DESCRIPTION>
					<TEXT>While the ICES1 bit is cleared (zero), the Timer/Counter1 contents are transferred to the Input Capture Register - ICR1 - on the falling edge of the input capture pin - ICP. While the ICES1 bit is set (one), the Timer/Counter1 contents are transferred to the Input Capture Register - ICR1 - on the rising edge of the input capture pin - ICP.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT4>
					<NAME>WGM13</NAME>
					<DESCRIPTION>Waveform Generation Mode Bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>WGM12</NAME>
					<DESCRIPTION>Waveform Generation Mode Bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>CS12</NAME>
					<DESCRIPTION>Clock Select1 bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>CS11</NAME>
					<DESCRIPTION>Clock Select 1 bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>CS10</NAME>
					<DESCRIPTION>Clock Select bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</TCCR1B>
			<TCCR1C>
				<NAME>TCCR1C</NAME>
				<DESCRIPTION>Timer/Counter1 Control Register C</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$22</IO_ADDR>
				<MEM_ADDR>$42</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>FOC1A</NAME>
					<DESCRIPTION>Force Output Compare for Channel A</DESCRIPTION>
					<TEXT>The FOC1A/FOC1B bits are only active when the WGM13:0 bits specifies a non-PWM mode. However, for ensuring compatibility with future devices, these bits must be set to zero when TCCR1A is written when operating in a PWM mode. When writing a logical one to the FOC1A/FOC1B bit, an immediate compare match is forced on the Waveform Generation unit. The OC1A/OC1B output is changed according to its COM1x1:0 bits setting. Note that the FOC1A/FOC1B bits are implemented as strobes. Therefore it is the value present in the COM1x1:0 bits that determine the effect of the forced compare. A FOC1A/FOC1B strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare match (CTC) mode using OCR1A as TOP. The FOC1A/FOC1B bits are always read as zero</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>FOC1B</NAME>
					<DESCRIPTION>Force Output Compare for Channel B</DESCRIPTION>
					<TEXT>The FOC1A/FOC1B bits are only active when the WGM13:0 bits specifies a non-PWM mode. However, for ensuring compatibility with future devices, these bits must be set to zero when TCCR1A is written when operating in a PWM mode. When writing a logical one to the FOC1A/FOC1B bit, an immediate compare match is forced on the Waveform Generation unit. The OC1A/OC1B output is changed according to its COM1x1:0 bits setting. Note that the FOC1A/FOC1B bits are implemented as strobes. Therefore it is the value present in the COM1x1:0 bits that determine the effect of the forced compare. A FOC1A/FOC1B strobe will not generate any interrupt nor will it clear the timer in Clear Timer on Compare match (CTC) mode using OCR1A as TOP. The FOC1A/FOC1B bits are always read as zero</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
			</TCCR1C>
			<TCNT1H>
				<NAME>TCNT1H</NAME>
				<DESCRIPTION>Timer/Counter1 High Byte</DESCRIPTION>
				<TEXT>This 16-bit register contains the prescaled value of the 16-bit Timer/Counter1. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary register (TEMP). This temporary register is also used when accessing OCR1A, OCR1B and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt ro</TEXT>
				<IO_ADDR>$2D</IO_ADDR>
				<MEM_ADDR>$4D</MEM_ADDR>
				<ICON>io_timer.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>TCNT1H7</NAME>
					<DESCRIPTION>Timer/Counter1 High Byte bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>TCNT1H6</NAME>
					<DESCRIPTION>Timer/Counter1 High Byte bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>TCNT1H5</NAME>
					<DESCRIPTION>Timer/Counter1 High Byte bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>TCNT1H4</NAME>
					<DESCRIPTION>Timer/Counter1 High Byte bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>TCNT1H3</NAME>
					<DESCRIPTION>Timer/Counter1 High Byte bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>TCNT1H2</NAME>
					<DESCRIPTION>Timer/Counter1 High Byte bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>TCNT1H1</NAME>
					<DESCRIPTION>Timer/Counter1 High Byte bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>TCNT1H0</NAME>
					<DESCRIPTION>Timer/Counter1 High Byte bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</TCNT1H>
			<TCNT1L>
				<NAME>TCNT1L</NAME>
				<DESCRIPTION>Timer/Counter1 Low Byte</DESCRIPTION>
				<TEXT>This 16-bit register contains the prescaled value of the 16-bit Timer/Counter1. To ensure that both the high and low bytes are read and written simultaneously when the CPU accesses these registers, the access is performed using an 8-bit temporary register (TEMP). This temporary register is also used when accessing OCR1A, OCR1B and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrup</TEXT>
				<IO_ADDR>$2C</IO_ADDR>
				<MEM_ADDR>$4C</MEM_ADDR>
				<ICON>io_timer.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>TCNT1L7</NAME>
					<DESCRIPTION>Timer/Counter1 Low Byte bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>TCNT1L6</NAME>
					<DESCRIPTION>Timer/Counter1 Low Byte bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>TCNT1L5</NAME>
					<DESCRIPTION>Timer/Counter1 Low Byte bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>TCNT1L4</NAME>
					<DESCRIPTION>Timer/Counter1 Low Byte bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>TCNT1L3</NAME>
					<DESCRIPTION>Timer/Counter1 Low Byte bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>TCNT1L2</NAME>
					<DESCRIPTION>Timer/Counter1 Low Byte bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>TCNT1L1</NAME>
					<DESCRIPTION>Timer/Counter1 Low Byte bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>TCNT1L0</NAME>
					<DESCRIPTION>Timer/Counter1 Low Byte bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</TCNT1L>
			<OCR1AH>
				<NAME>OCR1AH</NAME>
				<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte</DESCRIPTION>
				<TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrupt</TEXT>
				<IO_ADDR>$2B</IO_ADDR>
				<MEM_ADDR>$4B</MEM_ADDR>
				<ICON>io_timer.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>OCR1AH7</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>OCR1AH6</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>OCR1AH5</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>OCR1AH4</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>OCR1AH3</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>OCR1AH2</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>OCR1AH1</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>OCR1AH0</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</OCR1AH>
			<OCR1AL>
				<NAME>OCR1AL</NAME>
				<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte</DESCRIPTION>
				<TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interru</TEXT>
				<IO_ADDR>$2A</IO_ADDR>
				<MEM_ADDR>$4A</MEM_ADDR>
				<ICON>io_timer.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>OCR1AL7</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>OCR1AL6</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>OCR1AL5</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>OCR1AL4</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>OCR1AL3</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>OCR1AL2</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>OCR1AL1</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>OCR1AL0</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</OCR1AL>
			<OCR1BH>
				<NAME>OCR1BH</NAME>
				<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte</DESCRIPTION>
				<TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrup</TEXT>
				<IO_ADDR>$29</IO_ADDR>
				<MEM_ADDR>$49</MEM_ADDR>
				<ICON>io_timer.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>OCR1AH7</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>OCR1AH6</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>OCR1AH5</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>OCR1AH4</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>OCR1AH3</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>OCR1AH2</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>OCR1AH1</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>OCR1AH0</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register High Byte bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</OCR1BH>
			<OCR1BL>
				<NAME>OCR1BL</NAME>
				<DESCRIPTION>Timer/Counter1 Output Compare Register Low Byte</DESCRIPTION>
				<TEXT>The output compare registers are 16-bit read/write registers. The Timer/Counter1 Output Compare Registers contain the data to be continuously compared with Timer/Counter1. Actions on compare matches are specified in the Timer/Counter1 Control and Status register.A compare match does only occur if Timer/Counter1 counts to the OCR value. A software write that sets TCNT1 and OCR1A or OCR1B to the same value does not generate a compare match. A compare match will set the compare interrupt flag in the CPU clock cycle following the compare event. Since the Output Compare Registers - OCR1A and OCR1B - are 16-bit registers, a temporary register TEMP is used when OCR1A/B are written to ensure that both bytes are updated simultaneously. When the CPU writes the high byte, OCR1AH or OCR1BH, the data is temporarily stored in the TEMP register. When the CPU writes the low byte, OCR1AL or OCR1BL, the TEMP register is simultaneously written to OCR1AH or OCR1BH. Consequently, the high byte OCR1AH or OCR1BH must be written first for a full 16-bit register write operation. The TEMP register is also used when accessing TCNT1, and ICR1. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interru</TEXT>
				<IO_ADDR>$28</IO_ADDR>
				<MEM_ADDR>$48</MEM_ADDR>
				<ICON>io_timer.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>OCR1AL7</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>OCR1AL6</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>OCR1AL5</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>OCR1AL4</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>OCR1AL3</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>OCR1AL2</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>OCR1AL1</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>OCR1AL0</NAME>
					<DESCRIPTION>Timer/Counter1 Outbut Compare Register Low Byte Bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</OCR1BL>
			<ICR1H>
				<NAME>ICR1H</NAME>
				<DESCRIPTION>Timer/Counter1 Input Capture Register High Byte</DESCRIPTION>
				<TEXT>The input capture register is a 16-bit read-only register. When the rising or falling edge (according to the input capture edge setting - ICES1) of the signal at the input capture pin -ICP - is detected, the current value of the Timer/Counter1 is transferred to the Input Capture Register - ICR1. At the same time, the input capture flag - ICF1 - is set (one). Since the Input Capture Register - ICR1 - is a 16-bit register, a temporary register TEMP is used when ICR1 is read to ensure that both bytes are read simultaneously. When the CPU reads the low byte ICR1L, the data is sent to the CPU and the data of the high byte ICR1H is placed in the TEMP register. When the CPU reads the data in the high byte ICR1H, the CPU receives the data in the TEMP register. Consequently, the low byte ICR1L must be accessed first for a full 16-bit register read operation. The TEMP register is also used when accessing TCNT1, OCR1A and OCR1B. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within interrup</TEXT>
				<IO_ADDR>$25</IO_ADDR>
				<MEM_ADDR>$45</MEM_ADDR>
				<ICON>io_timer.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>ICR1H7</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>ICR1H6</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>ICR1H5</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>ICR1H4</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>ICR1H3</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>ICR1H2</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>ICR1H1</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>ICR1H0</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register High Byte bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</ICR1H>
			<ICR1L>
				<NAME>ICR1L</NAME>
				<DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte</DESCRIPTION>
				<TEXT>The input capture register is a 16-bit read-only register. When the rising or falling edge (according to the input capture edge setting - ICES1) of the signal at the input capture pin -ICP - is detected, the current value of the Timer/Counter1 is transferred to the Input Capture Register - ICR1. At the same time, the input capture flag - ICF1 - is set (one). Since the Input Capture Register - ICR1 - is a 16-bit register, a temporary register TEMP is used when ICR1 is read to ensure that both bytes are read simultaneously. When the CPU reads the low byte ICR1L, the data is sent to the CPU and the data of the high byte ICR1H is placed in the TEMP register. When the CPU reads the data in the high byte ICR1H, the CPU receives the data in the TEMP register. Consequently, the low byte ICR1L must be accessed first for a full 16-bit register read operation. The TEMP register is also used when accessing TCNT1, OCR1A and OCR1B. If the main program and also interrupt routines perform access to registers using TEMP, interrupts must be disabled during access from the main program (and from interrupt routines if interrupts are allowed from within inte</TEXT>
				<IO_ADDR>$24</IO_ADDR>
				<MEM_ADDR>$44</MEM_ADDR>
				<ICON>io_timer.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>ICR1L7</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>ICR1L6</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>ICR1L5</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>ICR1L4</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>ICR1L3</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>ICR1L2</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>ICR1L1</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>ICR1L0</NAME>
					<DESCRIPTION>Timer/Counter1 Input Capture Register Low Byte bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</ICR1L>
		</TIMER_COUNTER_1>
		<WATCHDOG>
			<LIST>[WDTCR]</LIST>
			<LINK/>
			<ICON>io_watch.bmp</ICON>
			<ID/>
			<TEXT/>
			<WDTCR>
				<NAME>WDTCR</NAME>
				<DESCRIPTION>Watchdog Timer Control Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$21</IO_ADDR>
				<MEM_ADDR>$41</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>WDTIF</NAME>
					<DESCRIPTION>Watchdog Timeout Interrupt Flag</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>WDTIE</NAME>
					<DESCRIPTION>Watchdog Timeout Interrupt Enable</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>WDP3</NAME>
					<DESCRIPTION>Watchdog Timer Prescaler Bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>WDCE</NAME>
					<DESCRIPTION>Watchdog Change Enable</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>WDE</NAME>
					<DESCRIPTION>Watch Dog Enable</DESCRIPTION>
					<TEXT>When the WDE is set (one) the Watchdog Timer is enabled, and if the WDE is cleared (zero) the Watchdog Timer function is disabled. WDE can only be cleared if the WDTOE bit is set(one). To disable an enabled watchdog timer, the following procedure must be followed: 1. In the same operation, write a logical one to WDTOE and WDE. A logical one must be written to WDE even though it is set to one before the disable operation starts. 2. Within the next four clock cycles, write a logical 0 to WDE. This disables the watchdog</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>WDP2</NAME>
					<DESCRIPTION>Watch Dog Timer Prescaler bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>WDP1</NAME>
					<DESCRIPTION>Watch Dog Timer Prescaler bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>WDP0</NAME>
					<DESCRIPTION>Watch Dog Timer Prescaler bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</WDTCR>
		</WATCHDOG>
		<EXTERNAL_INTERRUPT>
			<LIST>[GIMSK:EIFR]</LIST>
			<LINK/>
			<ICON>io_ext.bmp</ICON>
			<ID/>
			<TEXT/>
			<GIMSK>
				<NAME>GIMSK</NAME>
				<DESCRIPTION>General Interrupt Mask Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$3B</IO_ADDR>
				<MEM_ADDR>$5B</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>INT1</NAME>
					<DESCRIPTION>External Interrupt Request 1 Enable</DESCRIPTION>
					<TEXT>When the INT1 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the external pin interrupt is enabled. The Interrupt Sense Control1 bits 1/0 (ISC11 and ISC10) in the MCU general Control Register (MCUCR) defines whether the external interrupt is activated on rising or falling edge of the INT1 pin or level sensed. Activity on the pin will cause an interrupt request even if INT1 is configured as an output. The corresponding interrupt of External Interrupt Request 1 is executed from program memory address $002. See also External Interrupts.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>INT0</NAME>
					<DESCRIPTION>External Interrupt Request 0 Enable</DESCRIPTION>
					<TEXT>When the INT0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the external pin interrupt is enabled. The Interrupt Sense Control0 bits 1/0 (ISC01 and ISC00) in the MCU general Control Register (MCUCR) defines whether the external interrupt is activated on rising or falling edge of the INT0 pin or level sensed. Activity on the pin will cause an interrupt request even if INT0 is configured as an output. The corresponding interrupt of External Interrupt Request 0 is executed from program memory address $001. See also External Interrupts.  Bits 5..0 - Res: Reserved bits</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>PCIE</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
			</GIMSK>
			<EIFR>
				<NAME>EIFR</NAME>
				<DESCRIPTION>Extended Interrupt Flag Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$3A</IO_ADDR>
				<MEM_ADDR>$5A</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>INTF1</NAME>
					<DESCRIPTION>External Interrupt Flag 1</DESCRIPTION>
					<TEXT>When an event on the INT1 pin triggers an interrupt request, INTF1 becomes set (one). If the I-bit in SREG and the INT1 bit in GIMSK are set (one), the MCU will jump to the interrupt vector at address $002. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>INTF0</NAME>
					<DESCRIPTION>External Interrupt Flag 0</DESCRIPTION>
					<TEXT>When an event on the INT0 pin triggers an interrupt request, INTF0 becomes set (one). If the I-bit in SREG and the INT0 bit in GIMSK are set (one), the MCU will jump to the interrupt vector at address $001. The flag is cleared when the interrupt routine is executed. Alternatively, the flag can be cleared by writing a logical one to it. </TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>PCIF</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
			</EIFR>
		</EXTERNAL_INTERRUPT>
		<USART>
			<LIST>[UDR:UCSRA:UCSRB:UCSRC:UBRRH:UBRRL]</LIST>
			<LINK>[UBRRH:UBRRL]</LINK>
			<ICON>io_com.bmp</ICON>
			<ID/>
			<TEXT>The Universal Synchronous and Asynchronous serial Receiver and Transmitter (USART) is a highly flexible serial communication device. The main features are:  Full Duplex Operation (Independent Serial Receive and Transmit Registers)  Asynchronous or Synchronous Operation  Master or Slave Clocked Synchronous Operation  High Resolution Baud Rate Generator  Supports Serial Frames with 5, 6, 7, 8 or 9 Data Bits and 1 or 2 Stop Bits  Odd or Even Parity Generation and Parity Check Supported by Hardware  Data OverRun Detection  Framing Error Detection  Noise Filtering Includes False Start Bit Detection and Digital Low Pass Filter  Three Separate Interrupts on TX Complete, TX Data Register Empty and RX Complete  Multi-processor Communication Mode  Double Speed Asynchronous Comm</TEXT>
			<UDR>
				<NAME>UDR</NAME>
				<DESCRIPTION>USART I/O Data Register</DESCRIPTION>
				<TEXT>The UDR0 register is actually two physically separate registers sharing the same I/O address. When writing to the register, the USART Transmit Data register is written. When reading from UDR0, the USART Receive Data register is read.</TEXT>
				<IO_ADDR>$0C</IO_ADDR>
				<MEM_ADDR>$2C</MEM_ADDR>
				<ICON>io_com.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>UDR7</NAME>
					<DESCRIPTION>USART I/O Data Register bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>UDR6</NAME>
					<DESCRIPTION>USART I/O Data Register bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>UDR5</NAME>
					<DESCRIPTION>USART I/O Data Register bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>UDR4</NAME>
					<DESCRIPTION>USART I/O Data Register bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>UDR3</NAME>
					<DESCRIPTION>USART I/O Data Register bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>UDR2</NAME>
					<DESCRIPTION>USART I/O Data Register bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>UDR1</NAME>
					<DESCRIPTION>USART I/O Data Register bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>UDR0</NAME>
					<DESCRIPTION>USART I/O Data Register bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</UDR>
			<UCSRA>
				<NAME>UCSRA</NAME>
				<DESCRIPTION>USART Control and Status Register A</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$0B</IO_ADDR>
				<MEM_ADDR>$02B</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>RXC</NAME>
					<DESCRIPTION>USART Receive Complete</DESCRIPTION>
					<TEXT>This bit is set (one) when a received character is transferred from the Receiver Shift register to UDR0. The bit is set regard-less of any detected framing errors. When the RXCIE bit in UCR is set, the USART Receive Complete interrupt will be executed when RXC is set(one). RXC is cleared by reading UDR0. When interrupt-driven data reception is used, the USART Receive Complete Interrupt routine must read UDRin order to clear RXC, otherwise a new interrupt will occur once the interrupt routine terminates.</TEXT>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>TXC</NAME>
					<DESCRIPTION>USART Transmitt Complete</DESCRIPTION>
					<TEXT>This bit is set (one) when the entire character (including the stop bit) in the Transmit Shift register has been shifted out and no new data has been written to UDR0. This flag is especially useful in half-duplex communications interfaces, where a transmitting application must enter receive mode and free the communications bus immediately after completing the transmission. When the TXCIE bit in UCR is set, setting of TXC causes the USART Transmit Complete interrupt to be executed. TXC is cleared by hardware when executing the corresponding interrupt handling vector. Alternatively, the TXC bit is cleared (zero) by writing a logical one to the bi</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>UDRE</NAME>
					<DESCRIPTION>USART Data Register Empty</DESCRIPTION>
					<TEXT>This bit is set (one) when a character written to UDRis transferred to the Transmit shift register. Setting of this bit indicates that the transmitter is ready to receive a new character for transmission. When the UDR0IE bit in UCR is set, the USART Transmit Complete interrupt to be executed as long as UDR0E is set. UDR0E is cleared by writing UDR0. When interrupt-driven data transmittal is used, the USART Data Register Empty Interrupt routine must write UDRin order to clear UDR0E, otherwise a new interrupt will occur once the interrupt routine terminates. UDR0E is set (one) during reset to indicate that the transmitter is rea</TEXT>
					<ACCESS>R</ACCESS>
					<INIT_VAL>1</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>FE</NAME>
					<DESCRIPTION>Framing Error</DESCRIPTION>
					<TEXT>This bit is set if a Framing Error condition is detected, i.e. when the stop bit of an incoming character is zero. The FE bit is cleared when the stop bit of received data is one.</TEXT>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>DOR</NAME>
					<DESCRIPTION>Data overRun</DESCRIPTION>
					<TEXT>This bit is set if an Overrun condition is detected, i.e. when a character already present in the UDRregister is not read before the next character has been shifted into the Receiver Shift register. The OR bit is buffered, which means that it will be set once the valid data still in UDR0E is read. The OR bit is cleared (zero) when data is received and transferred to UDR0. </TEXT>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>UPE</NAME>
					<DESCRIPTION>USART Parity Error</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>U2X</NAME>
					<DESCRIPTION>Double the USART Transmission Speed</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>MPCM</NAME>
					<DESCRIPTION>Multi-processor Communication Mode</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</UCSRA>
			<UCSRB>
				<NAME>UCSRB</NAME>
				<DESCRIPTION>USART Control and Status Register B</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$0A</IO_ADDR>
				<MEM_ADDR>$02A</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>RXCIE</NAME>
					<DESCRIPTION>RX Complete Interrupt Enable</DESCRIPTION>
					<TEXT>Writing this bit to one enables interrupt on the RXC flag. A USART Receive Complete interrupt will be generated only if the RXCIE bit is written to one, the global interrupt flag in SREG is written to one and the RXC bit in UCSR0A is set.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>TXCIE</NAME>
					<DESCRIPTION>TX Complete Interrupt Enable</DESCRIPTION>
					<TEXT>Writing this bit to one enables interrupt on the TXC flag. A USART Transmit Complete interrupt will be generated only if the TXCIE bit is written to one, the global interrupt flag in SREG is written to one and the TXC bit in UCSR0A is set.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>UDRIE</NAME>
					<DESCRIPTION>USART Data register Empty Interrupt Enable</DESCRIPTION>
					<TEXT>Writing this bit to one enables interrupt on the UDR0E flag. A Data Register Empty interrupt will be generated only if the UDR0IE bit is written to one, the global interrupt flag in SREG is written to one and the UDR0E bit in UCSR0A is set.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>1</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>RXEN</NAME>
					<DESCRIPTION>Receiver Enable</DESCRIPTION>
					<TEXT>Writing this bit to one enables the USART receiver. The receiver will override normal port operation for the RxD pin when enabled. Disabling the receiver will flush the receive buffer invalidating the FE, DOR and PE flags.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>TXEN</NAME>
					<DESCRIPTION>Transmitter Enable</DESCRIPTION>
					<TEXT>Writing this bit to one enables the USART transmitter. The transmitter will override normal port operation for the TxD pin when enabled. The disabling of the transmitter (writing TXEN to zero) will not become effective until ongoing and pending transmissions are completed, i.e. when the transmit shift register and transmit buffer register does not contain data to be transmitted. When disabled, the transmitter will no longer override the TxD port.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>UCSZ2</NAME>
					<DESCRIPTION>Character Size</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>RXB8</NAME>
					<DESCRIPTION>Receive Data Bit 8</DESCRIPTION>
					<TEXT>RXB8 is the 9th data bit of the received character when operating with serial frames with 9 data bits. Must be read before reading the low bits from UDR0.</TEXT>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>TXB8</NAME>
					<DESCRIPTION>Transmit Data Bit 8</DESCRIPTION>
					<TEXT>TXB8 is the 9th data bit in the character to be transmitted when operating with serial frames with 9 data bits. Must be writ-ten before writing the low bits to UDR0.</TEXT>
					<ACCESS>W</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</UCSRB>
			<UCSRC>
				<NAME>UCSRC</NAME>
				<DESCRIPTION>USART Control and Status Register C</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$03</IO_ADDR>
				<MEM_ADDR>$23</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT6>
					<NAME>UMSEL</NAME>
					<DESCRIPTION>USART Mode Select</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>UPM1</NAME>
					<DESCRIPTION>Parity Mode Bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>1</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>UPM0</NAME>
					<DESCRIPTION>Parity Mode Bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>USBS</NAME>
					<DESCRIPTION>Stop Bit Select</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>UCSZ1</NAME>
					<DESCRIPTION>Character Size Bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>UCSZ0</NAME>
					<DESCRIPTION>Character Size Bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>UCPOL</NAME>
					<DESCRIPTION>Clock Polarity</DESCRIPTION>
					<TEXT/>
					<ACCESS>W</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</UCSRC>
			<UBRRH>
				<NAME>UBRRH</NAME>
				<DESCRIPTION>USART Baud Rate Register High Byte</DESCRIPTION>
				<TEXT>This is a 12-bit register which contains the USART baud rate. The UBRR0H contains the 4 most significant bits, and the UBRR0L contains the 8 least significant bits of the USART baud rate. Ongoing transmissions by the transmitter and receiver will be corrupted if the baud rate is changed. Writing UBRR0L will trigger an immediate update of the baud rate prescaler.</TEXT>
				<IO_ADDR>$02</IO_ADDR>
				<MEM_ADDR>$22</MEM_ADDR>
				<ICON>io_com.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT3>
					<NAME>UBRR11</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 11</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>UBRR10</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 10</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>UBRR9</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 9</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>UBRR8</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 8</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</UBRRH>
			<UBRRL>
				<NAME>UBRRL</NAME>
				<DESCRIPTION>USART Baud Rate Register Low Byte</DESCRIPTION>
				<TEXT>This is a 12-bit register which contains the USART baud rate. The UBRR0H contains the 4 most significant bits, and the UBRR0L contains the 8 least significant bits of the USART baud rate. Ongoing transmissions by the transmitter and receiver will be corrupted if the baud rate is changed. Writing UBRR0L will trigger an immediate update of the baud rate prescaler.</TEXT>
				<IO_ADDR>$09</IO_ADDR>
				<MEM_ADDR>$29</MEM_ADDR>
				<ICON>io_com.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>UBRR7</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>UBRR6</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>UBRR5</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>UBRR4</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>UBRR3</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>UBRR2</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>UBRR1</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>UBRR0</NAME>
					<DESCRIPTION>USART Baud Rate Register bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</UBRRL>
		</USART>
		<ANALOG_COMPARATOR>
			<LIST>[ACSR:DIDR]</LIST>
			<LINK/>
			<ICON>io_analo.bmp</ICON>
			<ID>AlgComp_06</ID>
			<TEXT/>
			<ACSR>
				<NAME>ACSR</NAME>
				<DESCRIPTION>Analog Comparator Control And Status Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$08</IO_ADDR>
				<MEM_ADDR>$28</MEM_ADDR>
				<ICON>io_analo.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>ACD</NAME>
					<DESCRIPTION>Analog Comparator Disable</DESCRIPTION>
					<TEXT>When this bit is written logic one, the power to the analog comparator is switched off. This bit can be set at any time to turn off the analog comparator. This will reduce power consumption in active and idle mode. When changing the ACD bit, the Analog Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR. Otherwise an interrupt can occur when the bit is changed.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>ACBG</NAME>
					<DESCRIPTION>Analog Comparator Bandgap Select</DESCRIPTION>
					<TEXT>When this bit is set, a fixed bandgap reference voltage replaces the positive input to the Analog Comparator. When this bit is cleared, AIN0 is applied to the positive input of the Analog Comparator. See Internal Voltage Reference on page 42.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>ACO</NAME>
					<DESCRIPTION>Analog Compare Output</DESCRIPTION>
					<TEXT>The output of the analog comparator is synchronized and then directly connected to ACO. The synchronization introduces a delay of 1-2 clock cycles.</TEXT>
					<ACCESS>R</ACCESS>
					<INIT_VAL>NA</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>ACI</NAME>
					<DESCRIPTION>Analog Comparator Interrupt Flag</DESCRIPTION>
					<TEXT>This bit is set by hardware when a comparator output event triggers the interrupt mode defined by ACIS1 and ACIS0. The Analog Comparator Interrupt routine is executed if the ACIE bit is set and the I-bit in SREG is set. ACI is cleared by hard-ware when executing the corresponding interrupt handling vector. Alternatively, ACI is cleared by writing a logic one to the flag.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>ACIE</NAME>
					<DESCRIPTION>Analog Comparator Interrupt Enable</DESCRIPTION>
					<TEXT>When the ACIE bit is written logic one and the I-bit in the Status Register is set, the analog comparator interrupt is acti-vated. When written logic zero, the interrupt is disabled.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>ACIC</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>ACIS1</NAME>
					<DESCRIPTION>Analog Comparator Interrupt Mode Select bit 1</DESCRIPTION>
					<TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>ACIS0</NAME>
					<DESCRIPTION>Analog Comparator Interrupt Mode Select bit 0</DESCRIPTION>
					<TEXT>These bits determine which comparator events that trigger the Analog Comparator interrupt.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</ACSR>
			<DIDR>
				<NAME>DIDR</NAME>
				<DESCRIPTION>Digital Input Disable Register 1</DESCRIPTION>
				<TEXT>When this bit is written logic one, the digital input buffer on the AIN1/0 pin is disabled. The corresponding PIN Register bit will always read as zero when this bit is set. When an analog signal is applied to the AIN1/0 pin and the digital input from this pin is not needed, this bit should be written logic one to reduce power consumption in the digital input buffer.</TEXT>
				<IO_ADDR>$01</IO_ADDR>
				<MEM_ADDR>$21</MEM_ADDR>
				<ICON>io_analo.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT1>
					<NAME>AIN1D</NAME>
					<DESCRIPTION>AIN1 Digital Input Disable</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>AIN0D</NAME>
					<DESCRIPTION>AIN0 Digital Input Disable</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</DIDR>
		</ANALOG_COMPARATOR>
		<PORTD>
			<LIST>[PORTD:DDRD:PIND]</LIST>
			<LINK/>
			<ICON>io_port.bmp</ICON>
			<ID>AVRSimIOPort.SimIOPort</ID>
			<TEXT/>
			<PORTD>
				<NAME>PORTD</NAME>
				<DESCRIPTION>Data Register, Port D</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$12</IO_ADDR>
				<MEM_ADDR>$32</MEM_ADDR>
				<ICON>io_port.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT6>
					<NAME>PORTD6</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>PORTD5</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>PORTD4</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>PORTD3</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>PORTD2</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>PORTD1</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>PORTD0</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</PORTD>
			<DDRD>
				<NAME>DDRD</NAME>
				<DIRECTION>Data Direction Register, Port D</DIRECTION>
				<TEXT/>
				<IO_ADDR>$11</IO_ADDR>
				<MEM_ADDR>$31</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT6>
					<NAME>DDRD6</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>DDRD5</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>DDRD4</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>DDRD3</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>DDRD2</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>DDRD1</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>DDRD0</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</DDRD>
			<PIND>
				<NAME>PIND</NAME>
				<DESCRIPTION>Input Pins, Port D</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$10</IO_ADDR>
				<MEM_ADDR>$30</MEM_ADDR>
				<ICON>io_port.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT6>
					<NAME>PIND6</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>PIND5</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>PIND4</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>PIND3</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>PIND2</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>PIND1</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>PIND0</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</PIND>
		</PORTD>
		<EEPROM>
			<LIST>[EEAR:EEDR:EECR]</LIST>
			<LINK/>
			<ICON>io_cpu.bmp</ICON>
			<ID>EEPROM_02.xml</ID>
			<TEXT/>
			<EEAR>
				<NAME>EEAR</NAME>
				<DESCRIPTION>EEPROM Read/Write Access</DESCRIPTION>
				<TEXT>The EEPROM access register is accessible in the I/O space. The write access time is in the range of 2.5 - 4ms, depending on the V CC voltages. A self-timing function, however, lets the user software detect when the next byte can be written. If the user code contains code that writes the EEPROM, some pre-caution must be taken. In heavily filtered power supplies, V CC is likely to rise or fall slowly on power-up/down. This causes the device for some period of time to run at a voltage lower than specified as minimum for the clock frequency used. CPU operation under these conditions is likely cause the program counter to perform unintentional jumps and eventually execute the EEPROM write code. To secure EEPROM integrity, the user is advised to use an external under-voltage reset circuit in this case. In order to prevent unintentional EEPROM writes, a specific write procedure must be followed. Refer to the description of the EEPROM Control Register for details on this. When the EEPROM is written, the CPU is halted for two clock cycles before the next instruction is executed. When the EEPROM is read, the CPU is halted for four clock cycles before the next instruction</TEXT>
				<IO_ADDR>$1E</IO_ADDR>
				<MEM_ADDR>$3E</MEM_ADDR>
				<ICON>io_cpu.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT6>
					<NAME>EEAR6</NAME>
					<DESCRIPTION>EEPROM Read/Write Access bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>EEAR5</NAME>
					<DESCRIPTION>EEPROM Read/Write Access bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>EEAR4</NAME>
					<DESCRIPTION>EEPROM Read/Write Access bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>EEAR3</NAME>
					<DESCRIPTION>EEPROM Read/Write Access bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>EEAR2</NAME>
					<DESCRIPTION>EEPROM Read/Write Access bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>EEAR1</NAME>
					<DESCRIPTION>EEPROM Read/Write Access bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>EEAR0</NAME>
					<DESCRIPTION>EEPROM Read/Write Access bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</EEAR>
			<EEDR>
				<NAME>EEDR</NAME>
				<DESCRIPTION>EEPROM Data Register</DESCRIPTION>
				<TEXT>For the EEPROM write operation, the EEDR register contains the data to be written to the EEPROM in the address given by the EEAR register. For the EEPROM read operation, the EEDR contains the data read out from the EEPROM at the address given by EEAR.</TEXT>
				<IO_ADDR>$1D</IO_ADDR>
				<MEM_ADDR>$3D</MEM_ADDR>
				<ICON>io_cpu.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>EEDR7</NAME>
					<DESCRIPTION>EEPROM Data Register bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>EEDR6</NAME>
					<DESCRIPTION>EEPROM Data Register bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>EEDR5</NAME>
					<DESCRIPTION>EEPROM Data Register bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>EEDR4</NAME>
					<DESCRIPTION>EEPROM Data Register bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>EEDR3</NAME>
					<DESCRIPTION>EEPROM Data Register bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>EEDR2</NAME>
					<DESCRIPTION>EEPROM Data Register bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>EEDR1</NAME>
					<DESCRIPTION>EEPROM Data Register bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>EEDR0</NAME>
					<DESCRIPTION>EEPROM Data Register bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</EEDR>
			<EECR>
				<NAME>EECR</NAME>
				<DESCRIPTION>EEPROM Control Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$1C</IO_ADDR>
				<MEM_ADDR>$3C</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT5>
					<NAME>EEPM1</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>EEPM0</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>EERIE</NAME>
					<DESCRIPTION>EEProm Ready Interrupt Enable</DESCRIPTION>
					<TEXT>When the I-bit in SREG and EERIE are set (one), the EEPROM Ready Interrupt is enabled. When cleared (zero), the interrupt is disabled. The EEPROM Ready Interrupt generates a constant interrupt when EEWE is cleared (zero).</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>EEMWE</NAME>
					<DESCRIPTION>EEPROM Master Write Enable</DESCRIPTION>
					<TEXT>The EEMWE bit determines whether setting EEWE to one causes the EEPROM to be written. When EEMWE is set(one) setting EEWE will write data to the EEPROM at the selected address If EEMWE is zero, setting EEWE will have no effect. When EEMWE has been set (one) by software, hardware clears the bit to zero after four clock cycles. See the description of the EEWE bit for a EEPROM write procedure.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>EEWE</NAME>
					<DESCRIPTION>EEPROM Write Enable</DESCRIPTION>
					<TEXT>The EEPROM Write Enable Signal EEWE is the write strobe to the EEPROM. When address and data are correctly set up, the EEWE bit must be set to write the value into the EEPROM. The EEMWE bit must be set when the logical one is written to EEWE, otherwise no EEPROM write takes place. The following procedure should be followed when writing the EEPROM (the order of steps 2 and 3 is unessential): 1. Wait until EEWE becomes zero. 2. Write new EEPROM address to EEARL and EEARH (optional). 3. Write new EEPROM data to EEDR (optional). 4. Write a logical one to the EEMWE bit in EECR (to be able to write a logical one to the EEMWE bit, the EEWE bit mustbewritten to zero in thesamecycle). 5. Within four clock cycles after setting EEMWE, write a logical one to EEWE. When the write access time (typically 2.5 ms at V CC =5Vor 4msatV CC = 2.7V) has elapsed, the EEWE bit is cleared (zero) by hardware. The user software can poll this bit and wait for a zero before writing the next byte. When EEWE has been set, the CPU is halted or two cycles before the next instruction is executed. Caution: An interrupt between step 4 and step 5 will make the write cycle fail, since the EEPROM Master Write Enable will time-out. If an interrupt routine accessing the EEPROM is interrupting another EEPROM access, the EEAR or EEDR regis-ter will be modified, causing the interrupted EEPROM access to fail. It is recommended to have the global interrupt flag cleared during the 4 last steps to avoid these problems.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>EERE</NAME>
					<DESCRIPTION>EEPROM Read Enable</DESCRIPTION>
					<TEXT>The EEPROM Read Enable Signal EERE is the read strobe to the EEPROM. When the correct address is set up in the EEAR register, the EERE bit must be set. When the EERE bit is cleared (zero) by hardware, requested data is found in the EEDR register. The EEPROM read access takes one instruction and there is no need to poll the EERE bit. When EERE has been set, the CPU is halted for four cycles before the next instruction is executed. The user should poll the EEWE bit before starting the read operation. If a write operation is in progress when new data or address is written to the EEPROM I/O registers, the write operation will be interrupted, and the result is undefined.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</EECR>
		</EEPROM>
		<PORTA>
			<LIST>[PORTA:DDRA:PINA]</LIST>
			<LINK/>
			<ICON>io_port.bmp</ICON>
			<ID>AVRSimIOPort.SimIOPort</ID>
			<TEXT/>
			<PORTA>
				<NAME>PORTA</NAME>
				<DESCRIPTION>Port A Data Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$1B</IO_ADDR>
				<MEM_ADDR>$3B</MEM_ADDR>
				<ICON>io_port.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT2>
					<NAME>PORTA2</NAME>
					<DESCRIPTION>Port A Data Register bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>PORTA1</NAME>
					<DESCRIPTION>Port A Data Register bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>PORTA0</NAME>
					<DESCRIPTION>Port A Data Register bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</PORTA>
			<DDRA>
				<NAME>DDRA</NAME>
				<DESCRIPTION>Port A Data Direction Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$1A</IO_ADDR>
				<MEM_ADDR>$3A</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT2>
					<NAME>DDRA2</NAME>
					<DESCRIPTION>Data Direction Register, Port A, bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>DDRA1</NAME>
					<DESCRIPTION>Data Direction Register, Port A, bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>DDRA0</NAME>
					<DESCRIPTION>Data Direction Register, Port A, bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</DDRA>
			<PINA>
				<NAME>PINA</NAME>
				<DESCRIPTION>Port A Input Pins</DESCRIPTION>
				<TEXT>The Port A Input Pins address - PINA - is not a register, and this address enables access to the physical value on each Port A pin. When reading PORTA the Port A Data Latch is read, and when reading PINA, the logical values present on the pins are read.</TEXT>
				<IO_ADDR>$19</IO_ADDR>
				<MEM_ADDR>$39</MEM_ADDR>
				<ICON>io_port.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT2>
					<NAME>PINA2</NAME>
					<DESCRIPTION>Input Pins, Port A bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>Hi-Z</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>PINA1</NAME>
					<DESCRIPTION>Input Pins, Port A bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>Hi-Z</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>PINA0</NAME>
					<DESCRIPTION>Input Pins, Port A bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>Hi-Z</INIT_VAL>
				</BIT0>
			</PINA>
		</PORTA>
		<CPU>
			<LIST>[SREG:SPL:SPMCSR:MCUCR:MCUSR:OSCCAL:GTCCR:PCMSK:GPIOR2:GPIOR1:GPIOR0]</LIST>
			<LINK>[SPH:SPL]</LINK>
			<ICON>io_cpu.bmp</ICON>
			<ID/>
			<TEXT/>
			<SREG>
				<NAME>SREG</NAME>
				<DESCRIPTION>Status Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$3F</IO_ADDR>
				<MEM_ADDR>$5F</MEM_ADDR>
				<ICON>io_sreg.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>I</NAME>
					<DESCRIPTION>Global Interrupt Enable</DESCRIPTION>
					<TEXT>The global interrupt enable bit must be set (one) for the interrupts to be enabled. The individual interrupt enable control is then performed in separate control registers. If the global interrupt enable bit is cleared (zero), none of the interrupts are enabled independent of the individual interrupt enable settings. The I-bit is cleared by hardware after an interrupt has occurred, and is set by the RETI instruction to enable subsequent interrupts.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>T</NAME>
					<DESCRIPTION>Bit Copy Storage</DESCRIPTION>
					<TEXT>The bit copy instructions BLD (Bit LoaD) and BST (Bit STore) use the T bit as source and destination for the operated bit. A bit from a register in the register file can be copied into T by the BST instruction, and a bit in T can be copied into a bit in a register in the register file by the BLD instruction.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>H</NAME>
					<DESCRIPTION>Half Carry Flag</DESCRIPTION>
					<TEXT>The half carry flag H indicates a half carry in some arithmetic operations. See the Instruction Set Description for detailed information.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>S</NAME>
					<DESCRIPTION>Sign Bit</DESCRIPTION>
					<TEXT>The S-bit is always an exclusive or between the negative flag N and the twos complement overflow flag V. See the Instruc-tion Set Description for detailed information.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>V</NAME>
					<DESCRIPTION>Two's Complement Overflow Flag</DESCRIPTION>
					<TEXT>The twos complement overflow flag V supports twos complement arithmetics. See the Instruction Set Description for detailed information.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>N</NAME>
					<DESCRIPTION>Negative Flag</DESCRIPTION>
					<TEXT>The negative flag N indicates a negative result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>Z</NAME>
					<DESCRIPTION>Zero Flag</DESCRIPTION>
					<TEXT>The zero flag Z indicates a zero result after the different arithmetic and logic operations. See the Instruction Set Description for detailed information.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>C</NAME>
					<DESCRIPTION>Carry Flag</DESCRIPTION>
					<TEXT>The carry flag C indicates a carry in an arithmetic or logic operation. See the Instruction Set Description for detailed information. Note that the status register is not automatically stored when entering an interrupt routine and restored when returning from an interrupt routine. This must be handled by software.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</SREG>
			<SPL>
				<NAME>SPL</NAME>
				<DESCRIPTION>Stack Pointer Low Byte</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$3D</IO_ADDR>
				<MEM_ADDR>$5D</MEM_ADDR>
				<ICON>io_sreg.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>SP7</NAME>
					<DESCRIPTION>Stack Pointer Bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>SP6</NAME>
					<DESCRIPTION>Stack Pointer Bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>SP5</NAME>
					<DESCRIPTION>Stack Pointer Bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>SP4</NAME>
					<DECRIPTION>Stack Pointer Bit 4</DECRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>SP3</NAME>
					<DESCRIPTION>Stack Pointer Bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>SP2</NAME>
					<DESCRIPTION>Stack Pointer Bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>SP1</NAME>
					<DESCRIPTION>Stack Pointer Bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>SP0</NAME>
					<DESCRIPTION>Stack Pointer Bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</SPL>
			<SPMCSR>
				<NAME>SPMCSR</NAME>
				<DESCRIPTION>Store Program Memory Control and Status register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$37</IO_ADDR>
				<MEM_ADDR>$57</MEM_ADDR>
				<ICON>io_sreg.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT4>
					<NAME>CTPB</NAME>
					<DECRIPTION>Clear Temporary Page Buffer</DECRIPTION>
					<TEXT>If the CTPB bit is written while filling the temporary page buffer, the temporary page buffer will be cleared and the data will be lost.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>RFLB</NAME>
					<DESCRIPTION>Read Fuse and Lock Bits</DESCRIPTION>
					<TEXT>An LPM instruction within three cycles after RFLB and SPMEN are set in the SPMCSR Register, will read either the Lock bits or the Fuse bits (depending on Z0 in the Zpointer) into the destination register.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>PGWRT</NAME>
					<DESCRIPTION>Page Write</DESCRIPTION>
					<TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes Page Write, with the data stored in the temporary buffer. The page address is taken from the high part of the Z-pointer. The data in R1 and R0 are ignored. The PGWRT bit will auto-clear upon completion of a Page Write, or if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire Page Write operation.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>PGERS</NAME>
					<DESCRIPTION>Page Erase</DESCRIPTION>
					<TEXT>If this bit is written to one at the same time as SPMEN, the next SPM instruction within four clock cycles executes Page Erase. The page address is taken from the high part of the Z-pointer. The data in R1 and R0 are ignored. The PGERS bit will auto-clear upon completion of a Page Erase, or if no SPM instruction is executed within four clock cycles. The CPU is halted during the entire Page Write operation.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>SPMEN</NAME>
					<DESCRIPTION>Store Program Memory Enable</DESCRIPTION>
					<TEXT>This bit enables the SPM instruction for the next four clock cycles. If written to one together with either CTPB, RFLB, PGWRT, or PGERS, the following SPM instruction will have a special meaning, see description above. If only SPMEN is written, the following SPM instruction will store the value in R1:R0 in the temporary page buffer addressed by the Z-pointer. The LSB of the Z-pointer is ignored. The SPMEN bit will auto-clear upon completion of an SPM instruction, or if no SPM instruction is executed within four clock cycles. During Page Erase and Page Write, the SPMEN bit remains high until the operation is completed. Writing any other combination than 10001, 01001, 00101, 00011 or 00001 in the lower five bits will have no effe</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</SPMCSR>
			<MCUCR>
				<NAME>MCUCR</NAME>
				<DESCRIPTION>MCU Control Register</DESCRIPTION>
				<TEXT>The MCU Control Register contains control bits for general MCU functions.</TEXT>
				<IO_ADDR>$35</IO_ADDR>
				<MEM_ADDR>$55</MEM_ADDR>
				<ICON>io_cpu.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>PUD</NAME>
					<DESCRIPTION>Pull-up Disable</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>SM1</NAME>
					<DESCRIPTION>Sleep Mode Select Bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>SE</NAME>
					<DESCRIPTION>Sleep Enable</DESCRIPTION>
					<TEXT>The SE bit must be set (one) to make the MCU enter the sleep mode when the SLEEP instruction is executed. To avoid the MCU entering the sleep mode unless it is the programmers purpose, it is recommended to set the Sleep Enable SE bit just before the execution of the SLEEP instruction.</TEXT>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>SM0</NAME>
					<DESCRIPTION>Sleep Mode Select Bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>ISC11</NAME>
					<DESCRIPTION>Interrupt Sense Control 1 bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>ISC10</NAME>
					<DESCRIPTION>Interrupt Sense Control 1 bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>ISC01</NAME>
					<DESCRIPTION>Interrupt Sense Control 0 bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>ISC00</NAME>
					<DESCRIPTION>Interrupt Sense Control 0 bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</MCUCR>
			<MCUSR>
				<NAME>MCUSR</NAME>
				<DESCRIPTION>MCU Status register</DESCRIPTION>
				<TEXT>The MCU Status Registerprovides information on which reset source caused a MCU reset.</TEXT>
				<IO_ADDR>$34</IO_ADDR>
				<MEM_ADDR>$54</MEM_ADDR>
				<ICON>io_cpu.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT3>
					<NAME>WDRF</NAME>
					<DESCRIPTION>Watchdog Reset Flag</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>BORF</NAME>
					<DESCRIPTION>Brown-out Reset Flag</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>EXTRF</NAME>
					<DESCRIPTION>External Reset Flag</DESCRIPTION>
					<TEXT>After a power-on reset, this bit is undefined (X). It will be set by an external reset. A watchdog reset will leave this bit unchanged.</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>PORF</NAME>
					<DESCRIPTION>Power-On Reset Flag</DESCRIPTION>
					<TEXT>This bit is set by a power-on reset. A watchdog reset or an external reset will leave this bit unchanged</TEXT>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</MCUSR>
			<OSCCAL>
				<NAME>OSCCAL</NAME>
				<DESCRIPTION>Oscillator Calibration Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$31</IO_ADDR>
				<MEM_ADDR>$51</MEM_ADDR>
				<ICON>io_sreg.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT6>
					<NAME>CAL6</NAME>
					<DESCRIPTION>Oscillatro Calibration Value Bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>CAL5</NAME>
					<DESCRIPTION>Oscillatro Calibration Value Bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>CAL4</NAME>
					<DESCRIPTION>Oscillatro Calibration Value Bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>CAL3</NAME>
					<DESCRIPTION>Oscillatro Calibration Value Bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>CAL2</NAME>
					<DESCRIPTION>Oscillatro Calibration Value Bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>CAL1</NAME>
					<DESCRIPTION>Oscillatro Calibration Value Bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>CAL0</NAME>
					<DESCRIPTION>Oscillatro Calibration Value Bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</OSCCAL>
			<GTCCR>
				<NAME>GTCCR</NAME>
				<DESCRIPTION>General Timer Counter Control Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$23</IO_ADDR>
				<MEM_ADDR>$43</MEM_ADDR>
				<ICON>io_sreg.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT0>
					<NAME>PSR10</NAME>
					<DESCRIPTION/>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</GTCCR>
			<PCMSK>
				<NAME>PCMSK</NAME>
				<DESCRIPTION>Pin-Change Mask register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$20</IO_ADDR>
				<MEM_ADDR>$40</MEM_ADDR>
				<ICON>io_sreg.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>PCINT7</NAME>
					<DESCRIPTION>Pin-Change Interrupt 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>PCINT6</NAME>
					<DESCRIPTION>Pin-Change Interrupt 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>PCINT5</NAME>
					<DESCRIPTION>Pin-Change Interrupt 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>PCINT4</NAME>
					<DESCRIPTION>Pin-Change Interrupt 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>PCINT3</NAME>
					<DESCRIPTION>Pin-Change Interrupt 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>PCINT2</NAME>
					<DESCRIPTION>Pin-Change Interrupt 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>PCINT1</NAME>
					<DESCRIPTION>Pin-Change Interrupt 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>PCINT0</NAME>
					<DESCRIPTION>Pin-Change Interrupt 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</PCMSK>
			<GPIOR2>
				<NAME>GPIOR2</NAME>
				<DESCRIPTION>General Purpose I/O Register 2</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$15</IO_ADDR>
				<MEM_ADDR>$35</MEM_ADDR>
				<ICON>io_sreg.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>GPIOR27</NAME>
					<DESCRIPTION>General Purpose I/O Register 2 bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>GPIOR26</NAME>
					<DESCRIPTION>General Purpose I/O Register 2 bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>GPIOR25</NAME>
					<DESCRIPTION>General Purpose I/O Register 2 bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>GPIOR24</NAME>
					<DESCRIPTION>General Purpose I/O Register 2 bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>GPIOR23</NAME>
					<DESCRIPTION>General Purpose I/O Register 2 bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>GPIOR22</NAME>
					<DESCRIPTION>General Purpose I/O Register 2 bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>GPIOR21</NAME>
					<DESCRIPTION>General Purpose I/O Register 2 bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>GPIOR20</NAME>
					<DESCRIPTION>General Purpose I/O Register 2 bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</GPIOR2>
			<GPIOR1>
				<NAME>GPIOR1</NAME>
				<DESCRIPTION>General Purpose I/O Register 1</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$14</IO_ADDR>
				<MEM_ADDR>$34</MEM_ADDR>
				<ICON>io_sreg.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>GPIOR17</NAME>
					<DESCRIPTION>General Purpose I/O Register 1 bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>GPIOR16</NAME>
					<DESCRIPTION>General Purpose I/O Register 1 bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>GPIOR15</NAME>
					<DESCRIPTION>General Purpose I/O Register 1 bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>GPIOR14</NAME>
					<DESCRIPTION>General Purpose I/O Register 1 bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>GPIOR13</NAME>
					<DESCRIPTION>General Purpose I/O Register 1 bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>GPIOR12</NAME>
					<DESCRIPTION>General Purpose I/O Register 1 bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>GPIOR11</NAME>
					<DESCRIPTION>General Purpose I/O Register 1 bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>GPIOR10</NAME>
					<DESCRIPTION>General Purpose I/O Register 1 bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</GPIOR1>
			<GPIOR0>
				<NAME>GPIOR0</NAME>
				<DESCRIPTION>General Purpose I/O Register 0</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$13</IO_ADDR>
				<MEM_ADDR>$33</MEM_ADDR>
				<ICON>io_sreg.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>GPIOR07</NAME>
					<DESCRIPTION>General Purpose I/O Register 0 bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>GPIOR06</NAME>
					<DESCRIPTION>General Purpose I/O Register 0 bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>GPIOR05</NAME>
					<DESCRIPTION>General Purpose I/O Register 0 bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>GPIOR04</NAME>
					<DESCRIPTION>General Purpose I/O Register 0 bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>GPIOR03</NAME>
					<DESCRIPTION>General Purpose I/O Register 0 bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>GPIOR02</NAME>
					<DESCRIPTION>General Purpose I/O Register 0 bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>GPIOR01</NAME>
					<DESCRIPTION>General Purpose I/O Register 0 bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>GPIOR00</NAME>
					<DESCRIPTION>General Purpose I/O Register 0 bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</GPIOR0>
		</CPU>
		<USI>
			<LIST>[USIDR:USISR:USICR]</LIST>
			<LINK/>
			<ICON>io_com.bmp</ICON>
			<ID/>
			<TEXT>Universal Serial Interface</TEXT>
			<USIDR>
				<NAME>USIDR</NAME>
				<DESCRIPTION>USI Data Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$0F</IO_ADDR>
				<MEM_ADDR>$2F</MEM_ADDR>
				<ICON>io_com.bmp</ICON>
				<DISPLAY_BITS>N</DISPLAY_BITS>
				<BIT7>
					<NAME>USIDR7</NAME>
					<DESCRIPTION>USI Data Register bit 7</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>USIDR6</NAME>
					<DESCRIPTION>USI Data Register bit 6</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>USIDR5</NAME>
					<DESCRIPTION>USI Data Register bit 5</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>USIDR4</NAME>
					<DESCRIPTION>USI Data Register bit 4</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>USIDR3</NAME>
					<DESCRIPTION>USI Data Register bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>USIDR2</NAME>
					<DESCRIPTION>USI Data Register bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>USIDR1</NAME>
					<DESCRIPTION>USI Data Register bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>USIDR0</NAME>
					<DESCRIPTION>USI Data Register bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</USIDR>
			<USISR>
				<NAME>USISR</NAME>
				<DESCRIPTION>USI Status Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$0E</IO_ADDR>
				<MEM_ADDR>$2E</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>USISIF</NAME>
					<DESCRIPTION>Start Condition Interrupt Flag</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>USIOIF</NAME>
					<DESCRIPTION>Counter Overflow Interrupt Flag</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>USIPF</NAME>
					<DESCRIPTION>Stop Condition Flag</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>1</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>USIDC</NAME>
					<DESCRIPTION>Data Output Collision</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>USICNT3</NAME>
					<DESCRIPTION>USI Counter Value Bit 3</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>USICNT2</NAME>
					<DESCRIPTION>USI Counter Value Bit 2</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>USICNT1</NAME>
					<DESCRIPTION>USI Counter Value Bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>USICNT0</NAME>
					<DESCRIPTION>USI Counter Value Bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</USISR>
			<USICR>
				<NAME>USICR</NAME>
				<DESCRIPTION>USI Control Register</DESCRIPTION>
				<TEXT/>
				<IO_ADDR>$0D</IO_ADDR>
				<MEM_ADDR>$2D</MEM_ADDR>
				<ICON>io_flag.bmp</ICON>
				<DISPLAY_BITS>Y</DISPLAY_BITS>
				<BIT7>
					<NAME>USISIE</NAME>
					<DESCRIPTION>Start Condition Interrupt Enable</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT7>
				<BIT6>
					<NAME>USIOIE</NAME>
					<DESCRIPTION>Counter Overflow Interrupt Enable</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT6>
				<BIT5>
					<NAME>USIWM1</NAME>
					<DESCRIPTION>USI Wire Mode Bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>1</INIT_VAL>
				</BIT5>
				<BIT4>
					<NAME>USIWM0</NAME>
					<DESCRIPTION>USI Wire Mode Bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT4>
				<BIT3>
					<NAME>USICS1</NAME>
					<DESCRIPTION>USI Clock Source Select Bit 1</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT3>
				<BIT2>
					<NAME>USICS0</NAME>
					<DESCRIPTION>USI Clock Source Select Bit 0</DESCRIPTION>
					<TEXT/>
					<ACCESS>RW</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT2>
				<BIT1>
					<NAME>USICLK</NAME>
					<DESCRIPTION>Clock Strobe</DESCRIPTION>
					<TEXT/>
					<ACCESS>R</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT1>
				<BIT0>
					<NAME>USITC</NAME>
					<DESCRIPTION>Toggle Clock Port Pin</DESCRIPTION>
					<TEXT/>
					<ACCESS>W</ACCESS>
					<INIT_VAL>0</INIT_VAL>
				</BIT0>
			</USICR>
		</USI>
	</IO_MODULE><ICE_SETTINGS><MODULE_LIST>[ICEPRO:SIMULATOR:JTAGICEmkII]</MODULE_LIST><ICEPRO>
			<emuconfig>0x10</emuconfig>
			<flashbits>0x0a</flashbits>
			<xramsthi>0x08</xramsthi>
			<xramstlo>0x00</xramstlo>
			<adrmask>0x78</adrmask>
			<extendio>0x00</extendio>
			<iofile>0x81</iofile>
		</ICEPRO>
		<SIMULATOR>
			<CoreID>AVRSimCoreV2.SimCoreV2</CoreID>
			<MemoryID>AVRSimMemory8bit.SimMemory8bit</MemoryID>
			<InterruptID>AVRSimInterrupt.SimInterrupt</InterruptID>
			<NmbIOModules>12</NmbIOModules>
			<PORTA>
				<ID>AVRSimIOPort.SimIOPort</ID>
				<MASK>0x07</MASK>
			</PORTA>
			<PORTB>
				<ID>AVRSimIOPort.SimIOPort</ID>
				<MASK>0xff</MASK>
			</PORTB>
			<PORTD>
				<ID>AVRSimIOPort.SimIOPort</ID>
				<MASK>0x7F</MASK>
			</PORTD>
			<EXTINT0>
				<ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
				<IntVector>0x01</IntVector>
				<EnableIOAdr>0x3b</EnableIOAdr>
				<EnableMask>0x40</EnableMask>
				<FlagIOAdr>0x3a</FlagIOAdr>
				<FlagMask>0x40</FlagMask>
				<ExtPinIOAdr>0x10</ExtPinIOAdr>
				<ExtPinMask>0x04</ExtPinMask>
				<SenseIOAdr>0x35</SenseIOAdr>
				<SenseMask>0x03</SenseMask>
			</EXTINT0>
			<EXTINT1>
				<ID>AVRSimIOExtInterrupt.SimIOExtInterrupt</ID>
				<IntVector>0x02</IntVector>
				<EnableIOAdr>0x3b</EnableIOAdr>
				<EnableMask>0x80</EnableMask>
				<FlagIOAdr>0x3a</FlagIOAdr>
				<FlagMask>0x80</FlagMask>
				<ExtPinIOAdr>0x10</ExtPinIOAdr>
				<ExtPinMask>0x08</ExtPinMask>
				<SenseIOAdr>0x35</SenseIOAdr>
				<SenseMask>0x0c</SenseMask>
			</EXTINT1>
			<PININT0>
				<ID>AVRSimIOPinChangeInterrupt.SimIOPinChangeInterrupt</ID>
				<IntVector>0x0B</IntVector>
				<EnableIOAdr>0x3B</EnableIOAdr>
				<EnableMask>0x20</EnableMask>
				<FlagIOAdr>0x3A</FlagIOAdr>
				<FlagMask>0x20</FlagMask>
				<PCMaskIOAdr>0x20</PCMaskIOAdr>
				<ExtPinIOAdr>0x16</ExtPinIOAdr>
				<ExtPinMask>0xFF</ExtPinMask>
			</PININT0>
			<TIMER0>
				<ID>AvrMasterTimer.MasterTimer</ID>
				<OvfVector>0x06</OvfVector>
				<CompAVector>0x0D</CompAVector>
				<CompBVector>0x0E</CompBVector>
				<OutputAdrA>0x18</OutputAdrA>
				<OutputAdrB>0x12</OutputAdrB>
				<OutputMaskA>0x04</OutputMaskA>
				<OutputMaskB>0x20</OutputMaskB>
				<CountAdr>0x10</CountAdr>
				<CountMask>0x10</CountMask>
			</TIMER0>
			<TIMER1>
				<ID>AVRSimIOTimert16pwm1.SimIOTimert16pwm1</ID>
				<IcpVector>0x03</IcpVector>
				<CompAVector>0x04</CompAVector>
				<CompBVector>0x0C</CompBVector>
				<OvfVector>0x05</OvfVector>
				<CountPinAdr>0x10</CountPinAdr>
				<CountPinMask>0x20</CountPinMask>
				<IcpPinAdr>0x10</IcpPinAdr>
				<IcpPinMask>0x40</IcpPinMask>
				<OutputAAdr>0x18</OutputAAdr>
				<OutputAMask>0x08</OutputAMask>
				<OutputBAdr>0x18</OutputBAdr>
				<OutputBMask>0x10</OutputBMask>
			</TIMER1>
			<EEPROM>
				<ID>AVRSimIOEE.SimIOEE</ID>
				<IntVector>0x11</IntVector>
			</EEPROM>
			<ANALOGCOMP>
				<ID>AVRSimAC.SimIOAC</ID>
				<IntVector>0x0A</IntVector>
			</ANALOGCOMP>
			<USART>
				<ID>AVRSimIOUsart.SimIOUsart</ID>
				<RXVector>0x07</RXVector>
				<TXVector>0x09</TXVector>
				<UDREVector>0x08</UDREVector>
				<TXPinAddress>0x10</TXPinAddress>
				<TXPinMask>0x02</TXPinMask>
				<RXPinAddress>0x10</RXPinAddress>
				<RXPinMask>0x01</RXPinMask>
			</USART>
			<USI>
				<ID>AvrSimUSI.SimUSI</ID>
				<OvfVector>0x10</OvfVector>
				<StartVector>0x0F</StartVector>
			</USI>
			<DEFAULT_SETTINGS>
				<HighFuse>0x99</HighFuse>
				<ExtendedFuse>0xff</ExtendedFuse>
				<LowFuse>0xe1</LowFuse>
				<Lockbit>0xff</Lockbit>
			</DEFAULT_SETTINGS>
		</SIMULATOR>
		<JTAGICEmkII>
			<ID>0x910A</ID>
			<Interface>DebugWire</Interface>
			<!--Bit 0 in byte 0 is I/O location, bit 7 in byte 7 is I/O location 63-->
			<ucRead>0x0E,0xEF,0xFF,0x7F,0x7F,0xFF,0x7F,0xBF</ucRead>
			<ucWrite>0x0E,0xAE,0xBE,0x7D,0x7D,0xFF,0x7F,0xBA</ucWrite>
			<ucReadShadow>0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00</ucReadShadow>
			<ucWriteShadow>0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00</ucWriteShadow>
			<!--Bit 0 in byte 0 is extended I/O location, bit 7 in byte 7 is I/O location 63-->
			<ucExtRead>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtRead>
			<ucExtWrite>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtWrite>
			<ucExtReadShadow>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtReadShadow>
			<ucExtWriteShadow>0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00</ucExtWriteShadow>
			<!--Register locations etc.-->
			<ucIDRAddress>0x00</ucIDRAddress>
			<ucSPMCAddress>0X00</ucSPMCAddress>
			<ucRAMPZAddress>0X00</ucRAMPZAddress>
			<ulFlashPageSize>32</ulFlashPageSize>
			<ulEepromPageSize>4</ulEepromPageSize>
			<ulBootAddress>0x0000</ulBootAddress>
			<BootAddress11>0x0000</BootAddress11>
			<BootAddress10>0x0000</BootAddress10>
			<BootAddress01>0x0000</BootAddress01>
			<BootAddress00>0x0000</BootAddress00>
			<ucUpperExtIOLoc>0x00</ucUpperExtIOLoc>
			<ulFlashSize>0x800</ulFlashSize>
			<ulRegStart>0x0000,32</ulRegStart>
			<ulIoStart>0x0020,64</ulIoStart>
			<!--Other stuff-->
			<DWENmaskExt>0x00</DWENmaskExt>
			<DWENmaskHigh>0x80</DWENmaskHigh>
			<DWENmaskLow>0x00</DWENmaskLow>
			<SPIENmaskExt>0x00</SPIENmaskExt>
			<SPIENmaskHigh>0x20</SPIENmaskHigh>
			<SPIENmaskLow>0x00</SPIENmaskLow>
			<ucEepromInst>0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D, 0xBA, 0x0F, 0xB2, 0x0F, 0xBA, 0x0D, 0xBB, 0xBC, 0x99, 0xE1, 0xBB, 0xAC</ucEepromInst>
			<ucFlashInst>0xB2, 0x0F, 0x1F</ucFlashInst>
			<ucSPHaddr>0x3e</ucSPHaddr>
			<ucSPLaddr>0x3d</ucSPLaddr>
			<DWdatareg>0x1F</DWdatareg>
			<DWbasePC>0x00</DWbasePC>
			<Osccalshared>0x00</Osccalshared>
			<ucAllowFullPageBitstream>0x00</ucAllowFullPageBitstream>
			<uiStartSmallestBootLoaderSection>0x00</uiStartSmallestBootLoaderSection>
			<ucUseJTAGID>0x00</ucUseJTAGID>
		</JTAGICEmkII>
	</ICE_SETTINGS></AVRPART>
